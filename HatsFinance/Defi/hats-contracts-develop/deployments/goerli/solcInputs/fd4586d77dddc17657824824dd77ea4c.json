{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (interfaces/IERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20Upgradeable.sol\";\nimport \"../token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626Upgradeable is IERC20Upgradeable, IERC20MetadataUpgradeable {\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n\n    event Withdraw(\n        address indexed caller,\n        address indexed receiver,\n        address indexed owner,\n        uint256 assets,\n        uint256 shares\n    );\n\n    /**\n     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n    function asset() external view returns (address assetTokenAddress);\n\n    /**\n     * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n    function totalAssets() external view returns (uint256 totalManagedAssets);\n\n    /**\n     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n    function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n    function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n    function maxMint(address receiver) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n    function previewMint(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n    function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n    /**\n     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n    function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n    /**\n     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) external returns (uint256 shares);\n\n    /**\n     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n    /**\n     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n    function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n    /**\n     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) external returns (uint256 assets);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/extensions/ERC4626.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../utils/SafeERC20Upgradeable.sol\";\nimport \"../../../interfaces/IERC4626Upgradeable.sol\";\nimport \"../../../utils/math/MathUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC4626 \"Tokenized Vault Standard\" as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[EIP-4626].\n *\n * This extension allows the minting and burning of \"shares\" (represented using the ERC20 inheritance) in exchange for\n * underlying \"assets\" through standardized {deposit}, {mint}, {redeem} and {burn} workflows. This contract extends\n * the ERC20 standard. Any additional extensions included along it would affect the \"shares\" token represented by this\n * contract and not the \"assets\" token which is an independent contract.\n *\n * CAUTION: Deposits and withdrawals may incur unexpected slippage. Users should verify that the amount received of\n * shares or assets is as expected. EOAs should operate through a wrapper that performs these checks such as\n * https://github.com/fei-protocol/ERC4626#erc4626router-and-base[ERC4626Router].\n *\n * _Available since v4.7._\n */\nabstract contract ERC4626Upgradeable is Initializable, ERC20Upgradeable, IERC4626Upgradeable {\n    using MathUpgradeable for uint256;\n\n    IERC20MetadataUpgradeable private _asset;\n\n    /**\n     * @dev Set the underlying asset contract. This must be an ERC20-compatible contract (ERC20 or ERC777).\n     */\n    function __ERC4626_init(IERC20MetadataUpgradeable asset_) internal onlyInitializing {\n        __ERC4626_init_unchained(asset_);\n    }\n\n    function __ERC4626_init_unchained(IERC20MetadataUpgradeable asset_) internal onlyInitializing {\n        _asset = asset_;\n    }\n\n    /** @dev See {IERC4262-asset}. */\n    function asset() public view virtual override returns (address) {\n        return address(_asset);\n    }\n\n    /** @dev See {IERC4262-totalAssets}. */\n    function totalAssets() public view virtual override returns (uint256) {\n        return _asset.balanceOf(address(this));\n    }\n\n    /** @dev See {IERC4262-convertToShares}. */\n    function convertToShares(uint256 assets) public view virtual override returns (uint256 shares) {\n        return _convertToShares(assets, MathUpgradeable.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-convertToAssets}. */\n    function convertToAssets(uint256 shares) public view virtual override returns (uint256 assets) {\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-maxDeposit}. */\n    function maxDeposit(address) public view virtual override returns (uint256) {\n        return _isVaultCollateralized() ? type(uint256).max : 0;\n    }\n\n    /** @dev See {IERC4262-maxMint}. */\n    function maxMint(address) public view virtual override returns (uint256) {\n        return type(uint256).max;\n    }\n\n    /** @dev See {IERC4262-maxWithdraw}. */\n    function maxWithdraw(address owner) public view virtual override returns (uint256) {\n        return _convertToAssets(balanceOf(owner), MathUpgradeable.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-maxRedeem}. */\n    function maxRedeem(address owner) public view virtual override returns (uint256) {\n        return balanceOf(owner);\n    }\n\n    /** @dev See {IERC4262-previewDeposit}. */\n    function previewDeposit(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, MathUpgradeable.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-previewMint}. */\n    function previewMint(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Up);\n    }\n\n    /** @dev See {IERC4262-previewWithdraw}. */\n    function previewWithdraw(uint256 assets) public view virtual override returns (uint256) {\n        return _convertToShares(assets, MathUpgradeable.Rounding.Up);\n    }\n\n    /** @dev See {IERC4262-previewRedeem}. */\n    function previewRedeem(uint256 shares) public view virtual override returns (uint256) {\n        return _convertToAssets(shares, MathUpgradeable.Rounding.Down);\n    }\n\n    /** @dev See {IERC4262-deposit}. */\n    function deposit(uint256 assets, address receiver) public virtual override returns (uint256) {\n        require(assets <= maxDeposit(receiver), \"ERC4626: deposit more than max\");\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4262-mint}. */\n    function mint(uint256 shares, address receiver) public virtual override returns (uint256) {\n        require(shares <= maxMint(receiver), \"ERC4626: mint more than max\");\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }\n\n    /** @dev See {IERC4262-withdraw}. */\n    function withdraw(\n        uint256 assets,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more than max\");\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }\n\n    /** @dev See {IERC4262-redeem}. */\n    function redeem(\n        uint256 shares,\n        address receiver,\n        address owner\n    ) public virtual override returns (uint256) {\n        require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\");\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }\n\n    /**\n     * @dev Internal conversion function (from assets to shares) with support for rounding direction.\n     *\n     * Will revert if assets > 0, totalSupply > 0 and totalAssets = 0. That corresponds to a case where any asset\n     * would represent an infinite amout of shares.\n     */\n    function _convertToShares(uint256 assets, MathUpgradeable.Rounding rounding) internal view virtual returns (uint256 shares) {\n        uint256 supply = totalSupply();\n        return\n            (assets == 0 || supply == 0)\n                ? assets.mulDiv(10**decimals(), 10**_asset.decimals(), rounding)\n                : assets.mulDiv(supply, totalAssets(), rounding);\n    }\n\n    /**\n     * @dev Internal conversion function (from shares to assets) with support for rounding direction.\n     */\n    function _convertToAssets(uint256 shares, MathUpgradeable.Rounding rounding) internal view virtual returns (uint256 assets) {\n        uint256 supply = totalSupply();\n        return\n            (supply == 0)\n                ? shares.mulDiv(10**_asset.decimals(), 10**decimals(), rounding)\n                : shares.mulDiv(totalAssets(), supply, rounding);\n    }\n\n    /**\n     * @dev Deposit/mint common workflow.\n     */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        // If _asset is ERC777, `transferFrom` can trigger a reenterancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transfered and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20Upgradeable.safeTransferFrom(_asset, caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }\n\n    /**\n     * @dev Withdraw/redeem common workflow.\n     */\n    function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If _asset is ERC777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transfered, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20Upgradeable.safeTransfer(_asset, receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }\n\n    function _isVaultCollateralized() private view returns (bool) {\n        return totalAssets() > 0 || totalSupply() == 0;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/governance/TimelockController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (governance/TimelockController.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../access/AccessControl.sol\";\nimport \"../token/ERC721/IERC721Receiver.sol\";\nimport \"../token/ERC1155/IERC1155Receiver.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract TimelockController is AccessControl, IERC721Receiver, IERC1155Receiver {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELLER_ROLE = keccak256(\"CANCELLER_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with a given `minDelay`, and a list of\n     * initial proposers and executors. The proposers receive both the\n     * proposer and the canceller role (for backward compatibility). The\n     * executors receive the executor role.\n     *\n     * NOTE: At construction, both the deployer and the timelock itself are\n     * administrators. This helps further configuration of the timelock by the\n     * deployer. After configuration is done, it is recommended that the\n     * deployer renounces its admin position and relies on timelocked\n     * operations to perform future maintenance.\n     */\n    constructor(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors\n    ) {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(CANCELLER_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // deployer + self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // register proposers and cancellers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n            _setupRole(CANCELLER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, AccessControl) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool registered) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not.\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready or not.\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\n        uint256 timestamp = getTimestamp(id);\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256 duration) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits a {CallScheduled} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to becomes valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'canceller' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata payload,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, payload, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        _execute(target, value, payload);\n        emit CallExecuted(id, 0, target, value, payload);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes calldata payload = payloads[i];\n            _execute(target, value, payload);\n            emit CallExecuted(id, i, target, value, payload);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     */\n    function _execute(\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) internal virtual {\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/governance/utils/IVotes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n *\n * _Available since v4.5._\n */\ninterface IVotes {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).\n     */\n    function getPastVotes(address account, uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Capped.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Capped.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\n\n/**\n * @dev Extension of {ERC20} that adds a cap to the supply of tokens.\n */\nabstract contract ERC20Capped is ERC20 {\n    uint256 private immutable _cap;\n\n    /**\n     * @dev Sets the value of the `cap`. This value is immutable, it can only be\n     * set once during construction.\n     */\n    constructor(uint256 cap_) {\n        require(cap_ > 0, \"ERC20Capped: cap is 0\");\n        _cap = cap_;\n    }\n\n    /**\n     * @dev Returns the cap on the token's total supply.\n     */\n    function cap() public view virtual returns (uint256) {\n        return _cap;\n    }\n\n    /**\n     * @dev See {ERC20-_mint}.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        require(ERC20.totalSupply() + amount <= cap(), \"ERC20Capped: cap exceeded\");\n        super._mint(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-ERC20Permit.sol\";\nimport \"../../../utils/math/Math.sol\";\nimport \"../../../governance/utils/IVotes.sol\";\nimport \"../../../utils/math/SafeCast.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20Votes is IVotes, ERC20Permit {\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSA.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the merkle tree could be reinterpreted as a leaf value.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     *\n     * _Available since v4.7._\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     *\n     * _Available since v4.7._\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be proved to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * _Available since v4.7._\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and the sibling nodes in `proof`,\n     * consuming from one or the other at each step according to the instructions given by\n     * `proofFlags`.\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}\n     *\n     * _Available since v4.7._\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuild the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value for the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            return hashes[totalHashes - 1];\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/HATGovernanceArbitrator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Disclaimer https://github.com/hats-finance/hats-contracts/blob/main/DISCLAIMER.md\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./HATVault.sol\";\n\ncontract HATGovernanceArbitrator is Ownable {\n\n    function approveClaim(HATVault _vault, bytes32 _claimId) external onlyOwner {\n        _vault.challengeClaim(_claimId);\n        _vault.approveClaim(_claimId, 0);\n    }\n\n    function dismissClaim(HATVault _vault, bytes32 _claimId) external onlyOwner {\n        _vault.challengeClaim(_claimId);\n        _vault.dismissClaim(_claimId);\n    }\n\n}\n"
    },
    "contracts/HATTimelockController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Disclaimer https://github.com/hats-finance/hats-contracts/blob/main/DISCLAIMER.md\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/governance/TimelockController.sol\";\nimport \"./HATGovernanceArbitrator.sol\";\n\ncontract HATTimelockController is TimelockController {\n\n    constructor(\n        uint256 _minDelay,\n        address[] memory _proposers,\n        address[] memory _executors\n    // solhint-disable-next-line no-empty-blocks\n    ) TimelockController(_minDelay, _proposers, _executors) {}\n    \n    // The following functions are not subject to the timelock\n\n    function approveClaim(HATGovernanceArbitrator _arbitrator, HATVault _vault, bytes32 _claimId) external onlyRole(PROPOSER_ROLE) {\n        _arbitrator.approveClaim(_vault, _claimId);\n    }\n\n    function dismissClaim(HATGovernanceArbitrator _arbitrator, HATVault _vault, bytes32 _claimId) external onlyRole(PROPOSER_ROLE) {\n        _arbitrator.dismissClaim(_vault, _claimId);\n    }\n\n    function setDepositPause(HATVault _vault, bool _depositPause) external onlyRole(PROPOSER_ROLE) {\n        _vault.setDepositPause(_depositPause);\n    }\n\n    function setVaultVisibility(HATVault _vault, bool _visible) external onlyRole(PROPOSER_ROLE) {\n        _vault.registry().setVaultVisibility(address(_vault), _visible);\n    }\n\n    function setVaultDescription(HATVault _vault, string memory _descriptionHash) external onlyRole(PROPOSER_ROLE) {\n        _vault.setVaultDescription(_descriptionHash);\n    }\n\n    function setAllocPoint(HATVault _vault, IRewardController _rewardController, uint256 _allocPoint)\n    external onlyRole(PROPOSER_ROLE) {\n        _rewardController.setAllocPoint(address(_vault), _allocPoint);\n    }\n\n    function setCommittee(HATVault _vault, address _committee) external onlyRole(PROPOSER_ROLE) {\n        _vault.setCommittee(_committee);\n    }\n\n    function swapAndSend(\n        HATVaultsRegistry _registry,\n        address _asset,\n        address[] calldata _beneficiaries,\n        uint256 _amountOutMinimum,\n        address _routingContract,\n        bytes calldata _routingPayload\n    )\n    external\n    onlyRole(PROPOSER_ROLE) {\n        _registry.swapAndSend(\n            _asset,\n            _beneficiaries,\n            _amountOutMinimum,\n            _routingContract,\n            _routingPayload\n        );\n    }\n\n    function setEmergencyPaused(HATVaultsRegistry _registry, bool _isEmergencyPaused) external onlyRole(PROPOSER_ROLE) {\n        _registry.setEmergencyPaused(_isEmergencyPaused);\n    }\n}\n"
    },
    "contracts/HATToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Capped.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IHATToken.sol\";\n\ncontract HATToken is IHATToken, ERC20Votes, ERC20Capped, Ownable {\n\n    /// @notice Address which may mint new tokens\n    /// minter -> minting seedAmount\n    mapping (address => uint256) public minters;\n\n    /// @notice Whether the token is transferable or not\n    /// @dev Set to false on deployment, and can only be set to true by the owner and cannot be set back to false\n    bool public transferable;\n\n    /**\n     * @notice Construct a new HAT token\n     * @param _governance The owner of the token\n     */\n    constructor(address _governance) \n        ERC20(\"hats.finance\", \"HAT\") \n        ERC20Capped(100000000e18) \n        ERC20Permit(\"hats.finance\")\n    {\n        _transferOwnership(_governance);\n    }\n\n    function setMinter(address _minter, uint256 _seedAmount) external onlyOwner {\n        minters[_minter] = _seedAmount;\n        emit MinterSet(_minter, _seedAmount);\n    }\n\n    function setTransferable() external onlyOwner {\n        transferable = true;\n        emit TransferableSet();\n    }\n\n    function burn(uint256 _amount) external {\n        if (_amount == 0) revert ZeroAmount();\n        _burn(msg.sender, _amount);\n    }\n\n    function mint(address _account, uint256 _amount) external {\n        if (_amount == 0) revert ZeroAmount();\n        minters[msg.sender] -= _amount;\n        _mint(_account, _amount);\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal override {\n        if (!transferable) revert TransfersDisabled();\n        super._transfer(from, to, amount);\n    }\n\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal override(ERC20, ERC20Votes) {\n        super._afterTokenTransfer(from, to, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal override(ERC20, ERC20Votes) {\n        super._burn(account, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal override(ERC20Votes, ERC20Capped) {\n        super._mint(account, amount);\n    }\n\n}\n"
    },
    "contracts/HATVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Disclaimer https://github.com/hats-finance/hats-contracts/blob/main/DISCLAIMER.md\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./tokenlock/TokenLockFactory.sol\";\nimport \"./interfaces/IHATVault.sol\";\nimport \"./interfaces/IRewardController.sol\";\nimport \"./HATVaultsRegistry.sol\";\n\n/** @title A Hats.finance vault which holds the funds for a specific project's\n* bug bounties\n* @author Hats.finance\n* @notice The HATVault can be deposited into in a permissionless manner using\n* the vault’s native token. When a bug is submitted and approved, the bounty \n* is paid out using the funds in the vault. Bounties are paid out as a\n* percentage of the vault. The percentage is set according to the severity of\n* the bug. Vaults have regular safety periods (typically for an hour twice a\n* day) which are time for the committee to make decisions.\n*\n* In addition to the roles defined in the HATVaultsRegistry, every HATVault \n* has the roles:\n* Committee - The only address which can submit a claim for a bounty payout\n* and set the maximum bounty.\n* User - Anyone can deposit the vault's native token into the vault and \n* recieve shares for it. Shares represent the user's relative part in the\n* vault, and when a bounty is paid out, users lose part of their deposits\n* (based on percentage paid), but keep their share of the vault.\n* Users also receive rewards for their deposits, which can be claimed at any\n* time.\n* To withdraw previously deposited tokens, a user must first send a withdraw\n* request, and the withdrawal will be made available after a pending period.\n* Withdrawals are not permitted during safety periods or while there is an \n* active claim for a bounty payout.\n*\n* Bounties are payed out distributed between a few channels, and that \n* distribution is set upon creation (the hacker gets part in direct transfer,\n* part in vested reward and part in vested HAT token, part gets rewarded to\n* the committee, part gets swapped to HAT token and burned and/or sent to Hats\n* governance).\n*\n* This project is open-source and can be found at:\n* https://github.com/hats-finance/hats-contracts\n*/\ncontract HATVault is IHATVault, ERC4626Upgradeable, OwnableUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n    using MathUpgradeable for uint256;\n\n    struct Claim {\n        bytes32 claimId;\n        address beneficiary;\n        uint16 bountyPercentage;\n        // the address of the committee at the time of the submission, so that this committee will\n        // be paid their share of the bounty in case the committee changes before claim approval\n        address committee;\n        uint32 createdAt;\n        uint32 challengedAt;\n        uint256 bountyGovernanceHAT;\n        uint256 bountyHackerHATVested;\n        address arbitrator;\n        uint32 challengePeriod;\n        uint32 challengeTimeOutPeriod;\n        bool arbitratorCanChangeBounty;\n    }\n\n    struct PendingMaxBounty {\n        uint16 maxBounty;\n        uint32 timestamp;\n    }\n\n    uint256 public constant MAX_UINT = type(uint256).max;\n    uint16 public constant NULL_UINT16 = type(uint16).max;\n    uint32 public constant NULL_UINT32 = type(uint32).max;\n    address public constant NULL_ADDRESS = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\n    uint256 public constant HUNDRED_PERCENT = 1e4;\n    uint256 public constant HUNDRED_PERCENT_SQRD = 1e8;\n    uint256 public constant MAX_BOUNTY_LIMIT = 90e2; // Max bounty can be up to 90%\n    uint256 public constant MAX_WITHDRAWAL_FEE = 2e2; // Max fee is 2%\n    uint256 public constant MAX_COMMITTEE_BOUNTY = 10e2; // Max committee bounty can be up to 10%\n\n    uint256 public constant MINIMAL_AMOUNT_OF_SHARES = 1e3; // to reduce rounding errors, the number of shares is either 0, or > than this number\n\n    HATVaultsRegistry public registry;\n    ITokenLockFactory public tokenLockFactory;\n\n    Claim public activeClaim;\n\n    IRewardController[] public rewardControllers;\n\n    IHATVault.BountySplit public bountySplit;\n    uint16 public maxBounty;\n    uint32 public vestingDuration;\n    uint32 public vestingPeriods;\n    address public committee;\n\n    bool public committeeCheckedIn;\n    bool public depositPause;\n    uint256 public withdrawalFee;\n\n    uint256 internal nonce;\n\n    PendingMaxBounty public pendingMaxBounty;\n\n\n    // Time of when withdrawal period starts for every user that has an\n    // active withdraw request. (time when last withdraw request pending \n    // period ended, or 0 if last action was deposit or withdraw)\n    mapping(address => uint256) public withdrawEnableStartTime;\n\n    // the percentage of the total bounty to be swapped to HATs and sent to governance (out of {HUNDRED_PERCENT})\n    uint16 internal bountyGovernanceHAT;\n    // the percentage of the total bounty to be swapped to HATs and sent to the hacker via vesting contract (out of {HUNDRED_PERCENT})\n    uint16 internal bountyHackerHATVested;\n\n    // address of the arbitrator - which can dispute claims and override the committee's decisions\n    address internal arbitrator;\n    // time during which a claim can be challenged by the arbitrator\n    uint32 internal challengePeriod;\n    // time after which a challenged claim is automatically dismissed\n    uint32 internal challengeTimeOutPeriod;\n    // whether the arbitrator can change bounty of claims\n    ArbitratorCanChangeBounty internal arbitratorCanChangeBounty;\n\n    bool private _isEmergencyWithdraw;\n\n    modifier onlyRegistryOwner() {\n        if (registry.owner() != msg.sender) revert OnlyRegistryOwner();\n        _;\n    }\n\n    modifier onlyFeeSetter() {\n        if (registry.feeSetter() != msg.sender) revert OnlyFeeSetter();\n        _;\n    }\n\n    modifier onlyCommittee() {\n        if (committee != msg.sender) revert OnlyCommittee();\n        _;\n    }\n\n    modifier notEmergencyPaused() {\n        if (registry.isEmergencyPaused()) revert SystemInEmergencyPause();\n        _;\n    }\n\n    modifier noSafetyPeriod() {\n        uint256 _withdrawPeriod = registry.getWithdrawPeriod();\n        // disable withdraw for safetyPeriod (e.g 1 hour) after each withdrawPeriod(e.g 11 hours)\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp % (_withdrawPeriod + registry.getSafetyPeriod()) >= _withdrawPeriod)\n            revert SafetyPeriod();\n        _;\n    }\n\n    modifier noActiveClaim() {\n        if (activeClaim.createdAt != 0) revert ActiveClaimExists();\n        _;\n    }\n\n    modifier isActiveClaim(bytes32 _claimId) {\n        if (activeClaim.createdAt == 0) revert NoActiveClaimExists();\n        if (activeClaim.claimId != _claimId) revert ClaimIdIsNotActive();\n        _;\n    }\n\n    /** @notice See {IHATVault-initialize}. */\n    function initialize(IHATVault.VaultInitParams calldata _params) external initializer {\n        if (_params.maxBounty > MAX_BOUNTY_LIMIT)\n            revert MaxBountyCannotBeMoreThanMaxBountyLimit();\n        _validateSplit(_params.bountySplit);\n        __ERC20_init(string.concat(\"Hats Vault \", _params.name), string.concat(\"HAT\", _params.symbol));\n        __ERC4626_init(IERC20MetadataUpgradeable(address(_params.asset)));\n        rewardControllers = _params.rewardControllers;\n        _setVestingParams(_params.vestingDuration, _params.vestingPeriods);\n        HATVaultsRegistry _registry = HATVaultsRegistry(msg.sender);\n        maxBounty = _params.maxBounty;\n        bountySplit = _params.bountySplit;\n        committee = _params.committee;\n        depositPause = _params.isPaused;\n        registry = _registry;\n        __ReentrancyGuard_init();\n        _transferOwnership(_params.owner);\n        tokenLockFactory = _registry.tokenLockFactory();\n\n        // Set vault to use default registry values where applicable\n        arbitrator = NULL_ADDRESS;\n        bountyGovernanceHAT = NULL_UINT16;\n        bountyHackerHATVested = NULL_UINT16;\n        arbitratorCanChangeBounty = ArbitratorCanChangeBounty.DEFAULT;\n        challengePeriod = NULL_UINT32;\n        challengeTimeOutPeriod = NULL_UINT32;\n\n        emit SetVaultDescription(_params.descriptionHash);\n    }\n\n\n    /* ---------------------------------- Claim --------------------------------------- */\n\n    /** @notice See {IHATVault-submitClaim}. */\n    function submitClaim(address _beneficiary, uint16 _bountyPercentage, string calldata _descriptionHash)\n        external onlyCommittee noActiveClaim notEmergencyPaused returns (bytes32 claimId) {\n        HATVaultsRegistry _registry = registry;\n        uint256 withdrawPeriod = _registry.getWithdrawPeriod();\n        // require we are in safetyPeriod\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp % (withdrawPeriod + _registry.getSafetyPeriod()) < withdrawPeriod)\n            revert NotSafetyPeriod();\n        if (_bountyPercentage > maxBounty)\n            revert BountyPercentageHigherThanMaxBounty();\n        claimId = keccak256(abi.encodePacked(address(this), ++nonce));\n        activeClaim = Claim({\n            claimId: claimId,\n            beneficiary: _beneficiary,\n            bountyPercentage: _bountyPercentage,\n            committee: msg.sender,\n            // solhint-disable-next-line not-rely-on-time\n            createdAt: uint32(block.timestamp),\n            challengedAt: 0,\n            bountyGovernanceHAT: getBountyGovernanceHAT(),\n            bountyHackerHATVested: getBountyHackerHATVested(),\n            arbitrator: getArbitrator(),\n            challengePeriod: getChallengePeriod(),\n            challengeTimeOutPeriod: getChallengeTimeOutPeriod(),\n            arbitratorCanChangeBounty: getArbitratorCanChangeBounty()\n        });\n\n        emit SubmitClaim(\n            claimId,\n            msg.sender,\n            _beneficiary,\n            _bountyPercentage,\n            _descriptionHash\n        );\n    }\n\n    function challengeClaim(bytes32 _claimId) external isActiveClaim(_claimId) {\n        if (msg.sender != activeClaim.arbitrator && msg.sender != registry.owner())\n            revert OnlyArbitratorOrRegistryOwner();\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp >= activeClaim.createdAt + activeClaim.challengePeriod)\n            revert ChallengePeriodEnded();\n        if (activeClaim.challengedAt != 0) {\n            revert ClaimAlreadyChallenged();\n        } \n        // solhint-disable-next-line not-rely-on-time\n        activeClaim.challengedAt = uint32(block.timestamp);\n        emit ChallengeClaim(_claimId);\n    }\n\n    /** @notice See {IHATVault-approveClaim}. */\n    function approveClaim(bytes32 _claimId, uint16 _bountyPercentage) external nonReentrant isActiveClaim(_claimId) {\n        Claim memory _claim = activeClaim;\n        delete activeClaim;\n        \n        \n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp >= _claim.createdAt + _claim.challengePeriod + _claim.challengeTimeOutPeriod) {\n            // cannot approve an expired claim\n            revert ClaimExpired();\n        } \n        if (_claim.challengedAt != 0) {\n            // the claim was challenged, and only the arbitrator can approve it, within the timeout period\n            if (\n                msg.sender != _claim.arbitrator ||\n                // solhint-disable-next-line not-rely-on-time\n                block.timestamp >= _claim.challengedAt + _claim.challengeTimeOutPeriod\n            )\n                revert ChallengedClaimCanOnlyBeApprovedByArbitratorUntilChallengeTimeoutPeriod();\n            // the arbitrator can update the bounty if needed\n            if (_claim.arbitratorCanChangeBounty && _bountyPercentage != 0) {\n                _claim.bountyPercentage = _bountyPercentage;\n            }\n        } else {\n            // the claim can be approved by anyone if the challengePeriod passed without a challenge\n            if (\n                // solhint-disable-next-line not-rely-on-time\n                block.timestamp <= _claim.createdAt + _claim.challengePeriod\n            ) \n                revert UnchallengedClaimCanOnlyBeApprovedAfterChallengePeriod();\n        }\n\n        address tokenLock;\n\n        IHATVault.ClaimBounty memory claimBounty = _calcClaimBounty(\n            _claim.bountyPercentage,\n            _claim.bountyGovernanceHAT,\n            _claim.bountyHackerHATVested\n        );\n\n        IERC20 _asset = IERC20(asset());\n        if (claimBounty.hackerVested > 0) {\n            //hacker gets part of bounty to a vesting contract\n            tokenLock = tokenLockFactory.createTokenLock(\n                address(_asset),\n                0x0000000000000000000000000000000000000000, //this address as owner, so it can do nothing.\n                _claim.beneficiary,\n                claimBounty.hackerVested,\n                // solhint-disable-next-line not-rely-on-time\n                block.timestamp, //start\n                // solhint-disable-next-line not-rely-on-time\n                block.timestamp + vestingDuration, //end\n                vestingPeriods,\n                0, //no release start\n                0, //no cliff\n                ITokenLock.Revocability.Disabled,\n                false\n            );\n            _asset.safeTransfer(tokenLock, claimBounty.hackerVested);\n        }\n\n        _asset.safeTransfer(_claim.beneficiary, claimBounty.hacker);\n        _asset.safeTransfer(_claim.committee, claimBounty.committee);\n\n        // send to the registry the amount of tokens which should be swapped \n        // to HAT so it could call swapAndSend in a separate tx.\n        HATVaultsRegistry _registry = registry;\n        _asset.safeApprove(address(_registry), claimBounty.hackerHatVested + claimBounty.governanceHat);\n        _registry.addTokensToSwap(\n            _asset,\n            _claim.beneficiary,\n            claimBounty.hackerHatVested,\n            claimBounty.governanceHat\n        );\n\n        // make sure to reset approval\n        _asset.safeApprove(address(_registry), 0);\n\n        emit ApproveClaim(\n            _claimId,\n            msg.sender,\n            _claim.beneficiary,\n            _claim.bountyPercentage,\n            tokenLock,\n            claimBounty\n        );\n    }\n\n    /** @notice See {IHATVault-dismissClaim}. */\n    function dismissClaim(bytes32 _claimId) external isActiveClaim(_claimId) {\n        uint256 _challengeTimeOutPeriod = activeClaim.challengeTimeOutPeriod;\n        uint256 _challengedAt = activeClaim.challengedAt;\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp <= activeClaim.createdAt + activeClaim.challengePeriod + _challengeTimeOutPeriod) {\n            if (_challengedAt == 0) revert OnlyCallableIfChallenged();\n            if (\n                // solhint-disable-next-line not-rely-on-time\n                block.timestamp <= _challengedAt + _challengeTimeOutPeriod && \n                msg.sender != activeClaim.arbitrator\n            ) revert OnlyCallableByArbitratorOrAfterChallengeTimeOutPeriod();\n        } // else the claim is expired and should be dismissed\n        delete activeClaim;\n\n        emit DismissClaim(_claimId);\n    }\n    /* -------------------------------------------------------------------------------- */\n\n    /* ---------------------------------- Params -------------------------------------- */\n\n    /** @notice See {IHATVault-setCommittee}. */\n    function setCommittee(address _committee) external {\n        // vault owner can update committee only if committee was not checked in yet.\n        if (msg.sender == owner() && committee != msg.sender) {\n            if (committeeCheckedIn)\n                revert CommitteeAlreadyCheckedIn();\n        } else {\n            if (committee != msg.sender) revert OnlyCommittee();\n        }\n\n        committee = _committee;\n\n        emit SetCommittee(_committee);\n    }\n\n    /** @notice See {IHATVault-setVestingParams}. */\n    function setVestingParams(uint32 _duration, uint32 _periods) external onlyOwner {\n        _setVestingParams(_duration, _periods);\n    }\n\n    /** @notice See {IHATVault-setBountySplit}. */\n    function setBountySplit(IHATVault.BountySplit calldata _bountySplit) external onlyOwner noActiveClaim noSafetyPeriod {\n        _validateSplit(_bountySplit);\n        bountySplit = _bountySplit;\n        emit SetBountySplit(_bountySplit);\n    }\n\n    /** @notice See {IHATVault-setWithdrawalFee}. */\n    function setWithdrawalFee(uint256 _fee) external onlyFeeSetter {\n        if (_fee > MAX_WITHDRAWAL_FEE) revert WithdrawalFeeTooBig();\n        withdrawalFee = _fee;\n        emit SetWithdrawalFee(_fee);\n    }\n\n    /** @notice See {IHATVault-committeeCheckIn}. */\n    function committeeCheckIn() external onlyCommittee {\n        committeeCheckedIn = true;\n        emit CommitteeCheckedIn();\n    }\n\n    /** @notice See {IHATVault-setPendingMaxBounty}. */\n    function setPendingMaxBounty(uint16 _maxBounty) external onlyOwner noActiveClaim {\n        if (_maxBounty > MAX_BOUNTY_LIMIT)\n            revert MaxBountyCannotBeMoreThanMaxBountyLimit();\n        pendingMaxBounty.maxBounty = _maxBounty;\n        // solhint-disable-next-line not-rely-on-time\n        pendingMaxBounty.timestamp = uint32(block.timestamp);\n        emit SetPendingMaxBounty(_maxBounty);\n    }\n\n    /** @notice See {IHATVault-setMaxBounty}. */\n    function setMaxBounty() external onlyOwner noActiveClaim {\n        PendingMaxBounty memory _pendingMaxBounty = pendingMaxBounty;\n        if (_pendingMaxBounty.timestamp == 0) revert NoPendingMaxBounty();\n\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp - _pendingMaxBounty.timestamp < registry.getSetMaxBountyDelay())\n            revert DelayPeriodForSettingMaxBountyHadNotPassed();\n\n        uint16 _maxBounty = pendingMaxBounty.maxBounty;\n        maxBounty = _maxBounty;\n        delete pendingMaxBounty;\n        emit SetMaxBounty(_maxBounty);\n    }\n\n    /** @notice See {IHATVault-setDepositPause}. */\n    function setDepositPause(bool _depositPause) external onlyOwner {\n        depositPause = _depositPause;\n        emit SetDepositPause(_depositPause);\n    }\n\n    /** @notice See {IHATVault-setVaultDescription}. */\n    function setVaultDescription(string calldata _descriptionHash) external onlyRegistryOwner {\n        emit SetVaultDescription(_descriptionHash);\n    }\n\n    /** @notice See {IHATVault-addRewardController}. */\n    function addRewardController(IRewardController _rewardController) external onlyRegistryOwner noActiveClaim {\n        rewardControllers.push(_rewardController);\n        emit AddRewardController(_rewardController);\n    }\n    \n    /** @notice See {IHATVault-setHATBountySplit}. */\n    function setHATBountySplit(uint16 _bountyGovernanceHAT, uint16 _bountyHackerHATVested) external onlyRegistryOwner {\n        bountyGovernanceHAT = _bountyGovernanceHAT;\n        bountyHackerHATVested = _bountyHackerHATVested;\n\n        registry.validateHATSplit(getBountyGovernanceHAT(), getBountyHackerHATVested());\n\n        emit SetHATBountySplit(_bountyGovernanceHAT, _bountyHackerHATVested);\n    }\n\n    /** @notice See {IHATVault-setArbitrator}. */\n    function setArbitrator(address _arbitrator) external onlyRegistryOwner {\n        arbitrator = _arbitrator;\n        emit SetArbitrator(_arbitrator);\n    }\n\n    /** @notice See {IHATVault-setChallengePeriod}. */\n    function setChallengePeriod(uint32 _challengePeriod) external onlyRegistryOwner {\n        if (_challengePeriod != NULL_UINT32) {\n            registry.validateChallengePeriod(_challengePeriod);\n        }\n\n        challengePeriod = _challengePeriod;\n        \n        emit SetChallengePeriod(_challengePeriod);\n    }\n\n    /** @notice See {IHATVault-setChallengeTimeOutPeriod}. */\n    function setChallengeTimeOutPeriod(uint32 _challengeTimeOutPeriod) external onlyRegistryOwner {\n        if (_challengeTimeOutPeriod != NULL_UINT32) {\n            registry.validateChallengeTimeOutPeriod(_challengeTimeOutPeriod);\n        }\n\n        challengeTimeOutPeriod = _challengeTimeOutPeriod;\n        \n        emit SetChallengeTimeOutPeriod(_challengeTimeOutPeriod);\n    }\n\n    /** @notice See {IHATVault-setArbitratorCanChangeBounty}. */\n    function setArbitratorCanChangeBounty(ArbitratorCanChangeBounty _arbitratorCanChangeBounty) external onlyRegistryOwner {\n        arbitratorCanChangeBounty = _arbitratorCanChangeBounty;\n        emit SetArbitratorCanChangeBounty(_arbitratorCanChangeBounty);\n    }\n\n    /* -------------------------------------------------------------------------------- */\n\n    /* ---------------------------------- Vault --------------------------------------- */\n\n    /** @notice See {IHATVault-withdrawRequest}. */\n    function withdrawRequest() external nonReentrant {\n        // set the withdrawEnableStartTime time to be withdrawRequestPendingPeriod from now\n        // solhint-disable-next-line not-rely-on-time\n        uint256 _withdrawEnableStartTime = block.timestamp + registry.getWithdrawRequestPendingPeriod();\n        address msgSender = _msgSender();\n        withdrawEnableStartTime[msgSender] = _withdrawEnableStartTime;\n        emit WithdrawRequest(msgSender, _withdrawEnableStartTime);\n    }\n\n    /** @notice See {IHATVault-withdrawAndClaim}. */\n    function withdrawAndClaim(uint256 assets, address receiver, address owner) external returns (uint256 shares) {\n        shares = withdraw(assets, receiver, owner);\n        for (uint256 i = 0; i < rewardControllers.length;) { \n            rewardControllers[i].claimReward(address(this), owner);\n            unchecked { ++i; }\n        }\n    }\n\n    /** @notice See {IHATVault-redeemAndClaim}. */\n    function redeemAndClaim(uint256 shares, address receiver, address owner) external returns (uint256 assets) {\n        assets = redeem(shares, receiver, owner);\n        for (uint256 i = 0; i < rewardControllers.length;) { \n            rewardControllers[i].claimReward(address(this), owner);\n            unchecked { ++i; }\n        }\n    }\n\n    /** @notice See {IHATVault-emergencyWithdraw}. */\n    function emergencyWithdraw(address receiver) external returns (uint256 assets) {\n        _isEmergencyWithdraw = true;\n        address msgSender = _msgSender();\n        assets = redeem(balanceOf(msgSender), receiver, msgSender);\n        _isEmergencyWithdraw = false;\n    }\n\n    /** @notice See {IHATVault-withdraw}. */\n    function withdraw(uint256 assets, address receiver, address owner) \n        public override(IHATVault, ERC4626Upgradeable) virtual returns (uint256) {\n        (uint256 _shares, uint256 _fee) = previewWithdrawAndFee(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, _shares, _fee);\n\n        return _shares;\n    }\n\n    /** @notice See {IHATVault-redeem}. */\n    function redeem(uint256 shares, address receiver, address owner) \n        public override(IHATVault, ERC4626Upgradeable) virtual returns (uint256) {\n        (uint256 _assets, uint256 _fee) = previewRedeemAndFee(shares);\n        _withdraw(_msgSender(), receiver, owner, _assets, shares, _fee);\n\n        return _assets;\n    }\n\n    /** @notice See {IHATVault-deposit}. */\n    function deposit(uint256 assets, address receiver) public override(IHATVault, ERC4626Upgradeable) virtual returns (uint256) {\n        return super.deposit(assets, receiver);\n    }\n\n    /** @notice See {IHATVault-withdraw}. */\n    function withdraw(uint256 assets, address receiver, address owner, uint256 maxShares) public virtual returns (uint256) {\n        uint256 shares = withdraw(assets, receiver, owner);\n        if (shares > maxShares) revert WithdrawSlippageProtection();\n        return shares;\n    }\n\n    /** @notice See {IHATVault-redeem}. */\n    function redeem(uint256 shares, address receiver, address owner, uint256 minAssets) public virtual returns (uint256) {\n        uint256 assets = redeem(shares, receiver, owner);\n        if (assets < minAssets) revert RedeemSlippageProtection();\n        return assets;\n    }\n\n    /** @notice See {IHATVault-withdrawAndClaim}. */\n    function withdrawAndClaim(uint256 assets, address receiver, address owner, uint256 maxShares) external returns (uint256 shares) {\n        shares = withdraw(assets, receiver, owner, maxShares);\n        for (uint256 i = 0; i < rewardControllers.length;) { \n            rewardControllers[i].claimReward(address(this), owner);\n            unchecked { ++i; }\n        }\n    }\n\n    /** @notice See {IHATVault-redeemAndClaim}. */\n    function redeemAndClaim(uint256 shares, address receiver, address owner, uint256 minAssets) external returns (uint256 assets) {\n        assets = redeem(shares, receiver, owner, minAssets);\n        for (uint256 i = 0; i < rewardControllers.length;) { \n            rewardControllers[i].claimReward(address(this), owner);\n            unchecked { ++i; }\n        }\n    }\n\n    /** @notice See {IHATVault-deposit}. */\n    function deposit(uint256 assets, address receiver, uint256 minShares) external virtual returns (uint256) {\n        uint256 shares = deposit(assets, receiver);\n        if (shares < minShares) revert DepositSlippageProtection();\n        return shares;\n    }\n\n    /** @notice See {IHATVault-mint}. */\n    function mint(uint256 shares, address receiver, uint256 maxAssets) external virtual returns (uint256) {\n        uint256 assets = mint(shares, receiver);\n        if (assets > maxAssets) revert MintSlippageProtection();\n        return assets;\n    }\n\n    /** @notice See {IERC4626Upgradeable-maxDeposit}. */\n    function maxDeposit(address) public view virtual override(IERC4626Upgradeable, ERC4626Upgradeable) returns (uint256) {\n        return depositPause ? 0 : MAX_UINT;\n    }\n\n    /** @notice See {IERC4626Upgradeable-maxMint}. */\n    function maxMint(address) public view virtual override(IERC4626Upgradeable, ERC4626Upgradeable) returns (uint256) {\n        return depositPause ? 0 : MAX_UINT;\n    }\n\n    /** @notice See {IERC4626Upgradeable-maxWithdraw}. */\n    function maxWithdraw(address owner) public view virtual override(IERC4626Upgradeable, ERC4626Upgradeable) returns (uint256) {\n        if (activeClaim.createdAt != 0 || !_isWithdrawEnabledForUser(owner)) return 0;\n        return previewRedeem(balanceOf(owner));\n    }\n\n    /** @notice See {IERC4626Upgradeable-maxRedeem}. */\n    function maxRedeem(address owner) public view virtual override(IERC4626Upgradeable, ERC4626Upgradeable) returns (uint256) {\n        if (activeClaim.createdAt != 0 || !_isWithdrawEnabledForUser(owner)) return 0;\n        return balanceOf(owner);\n    }\n\n    /** @notice See {IERC4626Upgradeable-previewWithdraw}. */\n    function previewWithdraw(uint256 assets) public view virtual override(IERC4626Upgradeable, ERC4626Upgradeable) returns (uint256 shares) {\n        (shares,) = previewWithdrawAndFee(assets);\n    }\n\n    /** @notice See {IERC4626Upgradeable-previewRedeem}. */\n    function previewRedeem(uint256 shares) public view virtual override(IERC4626Upgradeable, ERC4626Upgradeable) returns (uint256 assets) {\n        (assets,) = previewRedeemAndFee(shares);\n    }\n\n    /** @notice See {IHATVault-previewWithdrawAndFee}. */\n    function previewWithdrawAndFee(uint256 assets) public view returns (uint256 shares, uint256 fee) {\n        uint256 _withdrawalFee = withdrawalFee;\n        fee = assets.mulDiv(_withdrawalFee, (HUNDRED_PERCENT - _withdrawalFee));\n        shares = _convertToShares(assets + fee, MathUpgradeable.Rounding.Up);\n    }\n\n    /** @notice See {IHATVault-previewRedeemAndFee}. */\n    function previewRedeemAndFee(uint256 shares) public view returns (uint256 assets, uint256 fee) {\n        uint256 _assetsPlusFee = _convertToAssets(shares, MathUpgradeable.Rounding.Down);\n        fee = _assetsPlusFee.mulDiv(withdrawalFee, HUNDRED_PERCENT);\n        unchecked { // fee will always be maximun 20% of _assetsPlusFee\n            assets = _assetsPlusFee - fee;\n        }\n    }\n\n    /* -------------------------------------------------------------------------------- */\n\n    /* --------------------------------- Getters -------------------------------------- */\n\n    /** @notice See {IHATVault-getBountyGovernanceHAT}. */\n    function getBountyGovernanceHAT() public view returns(uint16) {\n        uint16 _bountyGovernanceHAT = bountyGovernanceHAT;\n        if (_bountyGovernanceHAT != NULL_UINT16) {\n            return _bountyGovernanceHAT;\n        } else {\n            return registry.defaultBountyGovernanceHAT();\n        }\n    }\n\n    /** @notice See {IHATVault-getBountyHackerHATVested}. */\n    function getBountyHackerHATVested() public view returns(uint16) {\n        uint16 _bountyHackerHATVested = bountyHackerHATVested;\n        if (_bountyHackerHATVested != NULL_UINT16) {\n            return _bountyHackerHATVested;\n        } else {\n            return registry.defaultBountyHackerHATVested();\n        }\n    }\n\n    /** @notice See {IHATVault-getArbitrator}. */\n    function getArbitrator() public view returns(address) {\n        address _arbitrator = arbitrator;\n        if (_arbitrator != NULL_ADDRESS) {\n            return _arbitrator;\n        } else {\n            return registry.defaultArbitrator();\n        }\n    }\n\n    /** @notice See {IHATVault-getChallengePeriod}. */\n    function getChallengePeriod() public view returns(uint32) {\n        uint32 _challengePeriod = challengePeriod;\n        if (_challengePeriod != NULL_UINT32) {\n            return _challengePeriod;\n        } else {\n            return registry.defaultChallengePeriod();\n        }\n    }\n\n    /** @notice See {IHATVault-getChallengeTimeOutPeriod}. */\n    function getChallengeTimeOutPeriod() public view returns(uint32) {\n        uint32 _challengeTimeOutPeriod = challengeTimeOutPeriod;\n        if (_challengeTimeOutPeriod != NULL_UINT32) {\n            return _challengeTimeOutPeriod;\n        } else {\n            return registry.defaultChallengeTimeOutPeriod();\n        }\n    }\n\n    /** @notice See {IHATVault-getArbitratorCanChangeBounty}. */\n    function getArbitratorCanChangeBounty() public view returns(bool) {\n        ArbitratorCanChangeBounty _arbitratorCanChangeBounty = arbitratorCanChangeBounty;\n        if (_arbitratorCanChangeBounty != ArbitratorCanChangeBounty.DEFAULT) {\n            return _arbitratorCanChangeBounty == ArbitratorCanChangeBounty.YES;\n        } else {\n            return registry.defaultArbitratorCanChangeBounty();\n        }\n    }\n\n    /* -------------------------------------------------------------------------------- */\n\n    /* --------------------------------- Helpers -------------------------------------- */\n\n    /**\n    * @dev Deposit funds to the vault. Can only be called if the committee had\n    * checked in and deposits are not paused.\n    * @param caller Caller of the action (msg.sender)\n    * @param receiver Reciever of the shares from the deposit\n    * @param assets Amount of vault's native token to deposit\n    * @param shares Respective amount of shares to be received\n    */\n    function _deposit(\n        address caller,\n        address receiver,\n        uint256 assets,\n        uint256 shares\n    ) internal override virtual nonReentrant {\n        if (!committeeCheckedIn)\n            revert CommitteeNotCheckedInYet();\n        if (receiver == caller && withdrawEnableStartTime[receiver] != 0 ) {\n            // clear withdraw request if caller deposits in her own account\n            withdrawEnableStartTime[receiver] = 0;\n        }\n\n        super._deposit(caller, receiver, assets, shares);\n    }\n\n    // amount of shares correspond with assets + fee\n    function _withdraw(\n        address _caller,\n        address _receiver,\n        address _owner,\n        uint256 _assets,\n        uint256 _shares,\n        uint256 _fee\n    ) internal nonReentrant {\n        if (_assets == 0) revert WithdrawMustBeGreaterThanZero();\n        if (_caller != _owner) {\n            _spendAllowance(_owner, _caller, _shares);\n        }\n\n        _burn(_owner, _shares);\n\n        IERC20 _asset = IERC20(asset());\n        if (_fee > 0) {\n            _asset.safeTransfer(registry.owner(), _fee);\n        }\n        _asset.safeTransfer(_receiver, _assets);\n\n        emit Withdraw(_caller, _receiver, _owner, _assets, _shares);\n    }\n\n    function _beforeTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal virtual override {\n        if (_amount == 0) revert AmountCannotBeZero();\n        if (_from == _to) revert CannotTransferToSelf();\n        // deposit/mint/transfer\n        if (_to != address(0)) {\n            HATVaultsRegistry  _registry = registry;\n            if (_registry.isEmergencyPaused()) revert SystemInEmergencyPause();\n            // Cannot transfer or mint tokens to a user for which an active withdraw request exists\n            // because then we would need to reset their withdraw request\n            uint256 _withdrawEnableStartTime = withdrawEnableStartTime[_to];\n            if (_withdrawEnableStartTime != 0) {\n                // solhint-disable-next-line not-rely-on-time\n                if (block.timestamp <= _withdrawEnableStartTime + _registry.getWithdrawRequestEnablePeriod())\n                    revert CannotTransferToAnotherUserWithActiveWithdrawRequest();\n            }\n\n            for (uint256 i = 0; i < rewardControllers.length;) { \n                rewardControllers[i].commitUserBalance(_to, _amount, true);\n                unchecked { ++i; }\n            }\n        }\n        // withdraw/redeem/transfer\n        if (_from != address(0)) {\n            if (_amount > maxRedeem(_from)) revert RedeemMoreThanMax();\n            // if all is ok and withdrawal can be made - \n            // reset withdrawRequests[_pid][msg.sender] so that another withdrawRequest\n            // will have to be made before next withdrawal\n            withdrawEnableStartTime[_from] = 0;\n\n            if (!_isEmergencyWithdraw) {\n                for (uint256 i = 0; i < rewardControllers.length;) { \n                    rewardControllers[i].commitUserBalance(_from, _amount, false);\n                    unchecked { ++i; }\n                }\n            }\n        }\n    }\n\n    function _afterTokenTransfer(address, address, uint256) internal virtual override {\n        if (totalSupply() > 0 && totalSupply() < MINIMAL_AMOUNT_OF_SHARES) {\n          revert AmountOfSharesMustBeMoreThanMinimalAmount();\n        }\n    }\n\n    function _setVestingParams(uint32 _duration, uint32 _periods) internal {\n        if (_duration > 120 days) revert VestingDurationTooLong();\n        if (_periods == 0) revert VestingPeriodsCannotBeZero();\n        if (_duration < _periods) revert VestingDurationSmallerThanPeriods();\n        vestingDuration = _duration;\n        vestingPeriods = _periods;\n        emit SetVestingParams(_duration, _periods);\n    }\n\n    /**\n    * @dev Checks that the given user can perform a withdraw at this time\n    * @param _user Address of the user to check\n    */\n    function _isWithdrawEnabledForUser(address _user)\n        internal view\n        returns(bool)\n    {\n        HATVaultsRegistry _registry = registry;\n        uint256 _withdrawPeriod = _registry.getWithdrawPeriod();\n        // disable withdraw for safetyPeriod (e.g 1 hour) after each withdrawPeriod (e.g 11 hours)\n        // solhint-disable-next-line not-rely-on-time\n        if (block.timestamp % (_withdrawPeriod + _registry.getSafetyPeriod()) >= _withdrawPeriod)\n            return false;\n        // check that withdrawRequestPendingPeriod had passed\n        uint256 _withdrawEnableStartTime = withdrawEnableStartTime[_user];\n        // solhint-disable-next-line not-rely-on-time\n        return (block.timestamp >= _withdrawEnableStartTime &&\n        // check that withdrawRequestEnablePeriod had not passed and that the\n        // last action was withdrawRequest (and not deposit or withdraw, which\n        // reset withdrawRequests[_user] to 0)\n        // solhint-disable-next-line not-rely-on-time\n            block.timestamp <= _withdrawEnableStartTime + _registry.getWithdrawRequestEnablePeriod());\n    }\n\n    /**\n    * @dev calculate the specific bounty payout distribution, according to the\n    * predefined bounty split and the given bounty percentage\n    * @param _bountyPercentage The percentage of the vault's funds to be paid\n    * out as bounty\n    * @param _bountyGovernanceHAT The bountyGovernanceHAT at the time the claim was submitted\n    * @param _bountyHackerHATVested The bountyHackerHATVested at the time the claim was submitted\n    * @return claimBounty The bounty distribution for this specific claim\n    */\n    function _calcClaimBounty(\n        uint256 _bountyPercentage,\n        uint256 _bountyGovernanceHAT,\n        uint256 _bountyHackerHATVested\n    ) internal view returns(IHATVault.ClaimBounty memory claimBounty) {\n        uint256 _totalAssets = totalAssets();\n        if (_totalAssets == 0) {\n          return claimBounty;\n        }\n        if (_bountyPercentage > maxBounty)\n            revert BountyPercentageHigherThanMaxBounty();\n\n        uint256 _totalBountyAmount = _totalAssets * _bountyPercentage;\n\n        uint256 _governanceHatAmount = _totalBountyAmount.mulDiv(_bountyGovernanceHAT, HUNDRED_PERCENT_SQRD);\n        uint256 _hackerHatVestedAmount = _totalBountyAmount.mulDiv(_bountyHackerHATVested, HUNDRED_PERCENT_SQRD);\n\n        _totalBountyAmount -= (_governanceHatAmount + _hackerHatVestedAmount) * HUNDRED_PERCENT;\n\n        claimBounty.governanceHat = _governanceHatAmount;\n        claimBounty.hackerHatVested = _hackerHatVestedAmount;\n\n        uint256 _hackerVestedAmount = _totalBountyAmount.mulDiv(bountySplit.hackerVested, HUNDRED_PERCENT_SQRD);\n        uint256 _hackerAmount = _totalBountyAmount.mulDiv(bountySplit.hacker, HUNDRED_PERCENT_SQRD);\n\n        _totalBountyAmount -= (_hackerVestedAmount + _hackerAmount) * HUNDRED_PERCENT;\n\n        claimBounty.hackerVested = _hackerVestedAmount;\n        claimBounty.hacker = _hackerAmount;\n\n        // give all the tokens left to the committee to avoid rounding errors\n        claimBounty.committee = _totalBountyAmount / HUNDRED_PERCENT;\n    }\n\n    /** \n    * @dev Check that a given bounty split is legal, meaning that:\n    *   Each entry is a number between 0 and `HUNDRED_PERCENT`.\n    *   Except committee part which is capped at maximum of\n    *   `MAX_COMMITTEE_BOUNTY`.\n    *   Total splits should be equal to `HUNDRED_PERCENT`.\n    * function will revert in case the bounty split is not legal.\n    * @param _bountySplit The bounty split to check\n    */\n    function _validateSplit(IHATVault.BountySplit calldata _bountySplit) internal pure {\n        if (_bountySplit.committee > MAX_COMMITTEE_BOUNTY) revert CommitteeBountyCannotBeMoreThanMax();\n        if (_bountySplit.hackerVested +\n            _bountySplit.hacker +\n            _bountySplit.committee != HUNDRED_PERCENT)\n            revert TotalSplitPercentageShouldBeHundredPercent();\n    }\n\n    /* -------------------------------------------------------------------------------- */\n}\n"
    },
    "contracts/HATVaultsRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Disclaimer https://github.com/hats-finance/hats-contracts/blob/main/DISCLAIMER.md\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./tokenlock/TokenLockFactory.sol\";\nimport \"./interfaces/IHATVaultsRegistry.sol\";\nimport \"./HATVault.sol\";\n\n/** @title Registry to deploy Hats.finance vaults and manage shared parameters\n * @author Hats.finance\n * @notice Hats.finance is a proactive bounty protocol for white hat hackers and\n * security experts, where projects, community members, and stakeholders\n * incentivize protocol security and responsible disclosure.\n * Hats create scalable vaults using the project’s own token. The value of the\n * bounty increases with the success of the token and project.\n *\n * The owner of the registry has the permission to set time limits and bounty\n * parameters and change vaults' info, and to set the other registry roles -\n * fee setter and arbitrator.\n * The arbitrator can challenge submitted claims for bounty payouts made by\n * vaults' committees, approve them with a different bounty percentage or\n * dismiss them.\n * The fee setter can set the fee on withdrawals on all vaults.\n *\n * This project is open-source and can be found at:\n * https://github.com/hats-finance/hats-contracts\n *\n * @dev New hats.finance vaults should be created through a call to {createVault}\n * so that they are linked to the registry\n */\ncontract HATVaultsRegistry is IHATVaultsRegistry, Ownable {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n\n    // Used in {swapAndSend} to avoid a \"stack too deep\" error\n    struct SwapData {\n        uint256 amount;\n        uint256 amountUnused;\n        uint256 hatsReceived;\n        uint256 totalHackerReward;\n        uint256 governanceAmountSwapped;\n        uint256[] hackerRewards;\n        uint256 governanceHatReward;\n        uint256 usedPart;\n    }\n\n    uint16 public constant HUNDRED_PERCENT = 10000;\n    // the maximum percentage of the bounty that will be converted in HATs\n    uint16 public constant MAX_HAT_SPLIT = 2000;\n\n    address public immutable hatVaultImplementation;\n    address[] public hatVaults;\n    \n    // vault address => is visible\n    mapping(address => bool) public isVaultVisible;\n    // asset => hacker address => amount\n    mapping(address => mapping(address => uint256)) public hackersHatReward;\n    // asset => amount\n    mapping(address => uint256) public governanceHatReward;\n\n    // PARAMETERS FOR ALL VAULTS\n    IHATVaultsRegistry.GeneralParameters public generalParameters;\n    ITokenLockFactory public immutable tokenLockFactory;\n\n    // the token into which a part of the the bounty will be swapped into\n    IERC20 public HAT;\n    \n    // feeSetter sets the withdrawal fee\n    address public feeSetter;\n\n    // How the bountyGovernanceHAT and bountyHackerHATVested set how to divide the hats \n    // bounties of the vault, in percentages (out of `HUNDRED_PERCENT`)\n    // The precentages are taken from the total bounty\n \n    // the default percentage of the total bounty to be swapped to HATs and sent to governance\n    uint16 public defaultBountyGovernanceHAT;\n    // the default percentage of the total bounty to be swapped to HATs and sent to the hacker via vesting contract\n    uint16 public defaultBountyHackerHATVested;\n\n    address public defaultArbitrator;\n    bool public defaultArbitratorCanChangeBounty;\n\n    bool public isEmergencyPaused;\n    uint32 public defaultChallengePeriod;\n    uint32 public defaultChallengeTimeOutPeriod;\n\n    /**\n    * @notice initialize -\n    * @param _hatVaultImplementation The hat vault implementation address.\n    * @param _hatGovernance The governance address.\n    * @param _HAT the HAT token address\n    * @param _bountyGovernanceHAT The default percentage of a claim's total\n    * bounty to be swapped for HAT and sent to the governance\n    * @param _bountyHackerHATVested The default percentage of a claim's total\n    * bounty to be swapped for HAT and sent to a vesting contract for the hacker\n    *   _bountyGovernanceHAT + _bountyHackerHATVested must be less\n    *    than `HUNDRED_PERCENT`.\n    * @param _tokenLockFactory Address of the token lock factory to be used\n    * to create a vesting contract for the approved claim reporter.\n    */\n    constructor(\n        address _hatVaultImplementation,\n        address _hatGovernance,\n        address _defaultArbitrator,\n        address _HAT,\n        uint16 _bountyGovernanceHAT,\n        uint16 _bountyHackerHATVested,\n        ITokenLockFactory _tokenLockFactory\n    ) {\n        _transferOwnership(_hatGovernance);\n        hatVaultImplementation = _hatVaultImplementation;\n        HAT = IERC20(_HAT);\n\n        validateHATSplit(_bountyGovernanceHAT, _bountyHackerHATVested);\n        tokenLockFactory = _tokenLockFactory;\n        generalParameters = IHATVaultsRegistry.GeneralParameters({\n            hatVestingDuration: 90 days,\n            hatVestingPeriods: 90,\n            withdrawPeriod: 11 hours,\n            safetyPeriod: 1 hours,\n            setMaxBountyDelay: 2 days,\n            withdrawRequestEnablePeriod: 7 days,\n            withdrawRequestPendingPeriod: 7 days,\n            claimFee: 0\n        });\n\n        defaultBountyGovernanceHAT = _bountyGovernanceHAT;\n        defaultBountyHackerHATVested = _bountyHackerHATVested;\n        defaultArbitrator = _defaultArbitrator;\n        defaultChallengePeriod = 3 days;\n        defaultChallengeTimeOutPeriod = 5 weeks;\n        defaultArbitratorCanChangeBounty = true;\n        emit RegistryCreated(\n            _hatVaultImplementation,\n            _HAT,\n            address(_tokenLockFactory),\n            generalParameters,\n            _bountyGovernanceHAT,\n            _bountyHackerHATVested,\n            _hatGovernance,\n            _defaultArbitrator,\n            defaultChallengePeriod,\n            defaultChallengeTimeOutPeriod,\n            defaultArbitratorCanChangeBounty\n        );\n    }\n\n    /** @notice See {IHATVaultsRegistry-setSwapToken}. */\n    function setSwapToken(address _swapToken) external onlyOwner {\n        HAT = IERC20(_swapToken);\n        emit SetSwapToken(_swapToken);\n    }\n\n    /** @notice See {IHATVaultsRegistry-setEmergencyPaused}. */\n    function setEmergencyPaused(bool _isEmergencyPaused) external onlyOwner {\n        isEmergencyPaused = _isEmergencyPaused;\n        emit SetEmergencyPaused(_isEmergencyPaused);\n    }\n\n    /** @notice See {IHATVaultsRegistry-logClaim}. */\n    function logClaim(string calldata _descriptionHash) external payable {\n        uint256 _claimFee = generalParameters.claimFee;\n        if (_claimFee > 0) {\n            if (msg.value < _claimFee)\n                revert NotEnoughFeePaid();\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success,) = payable(owner()).call{value: msg.value}(\"\");\n            if (!success) revert ClaimFeeTransferFailed();\n        }\n        emit LogClaim(msg.sender, _descriptionHash);\n    }\n\n    /** @notice See {IHATVaultsRegistry-setDefaultHATBountySplit}. */\n    function setDefaultHATBountySplit(\n        uint16 _defaultBountyGovernanceHAT,\n        uint16 _defaultBountyHackerHATVested\n    ) external onlyOwner {\n        validateHATSplit(_defaultBountyGovernanceHAT, _defaultBountyHackerHATVested);\n        defaultBountyGovernanceHAT = _defaultBountyGovernanceHAT;\n        defaultBountyHackerHATVested = _defaultBountyHackerHATVested;\n        emit SetDefaultHATBountySplit(_defaultBountyGovernanceHAT, _defaultBountyHackerHATVested);\n\n    }\n   \n    /** @notice See {IHATVaultsRegistry-setDefaultArbitrator}. */\n    function setDefaultArbitrator(address _defaultArbitrator) external onlyOwner {\n        defaultArbitrator = _defaultArbitrator;\n        emit SetDefaultArbitrator(_defaultArbitrator);\n    }\n\n    /** @notice See {IHATVaultsRegistry-setDefaultChallengePeriod}. */\n    function setDefaultChallengePeriod(uint32 _defaultChallengePeriod) external onlyOwner {\n        validateChallengePeriod(_defaultChallengePeriod);\n        defaultChallengePeriod = _defaultChallengePeriod;\n        emit SetDefaultChallengePeriod(_defaultChallengePeriod);\n    }\n\n    /** @notice See {IHATVaultsRegistry-setDefaultChallengeTimeOutPeriod}. */\n    function setDefaultChallengeTimeOutPeriod(uint32 _defaultChallengeTimeOutPeriod) external onlyOwner {\n        validateChallengeTimeOutPeriod(_defaultChallengeTimeOutPeriod);\n        defaultChallengeTimeOutPeriod = _defaultChallengeTimeOutPeriod;\n        emit SetDefaultChallengeTimeOutPeriod(_defaultChallengeTimeOutPeriod);\n    }\n\n    /** @notice See {IHATVaultsRegistry-setDefaultArbitratorCanChangeBounty}. */\n    function setDefaultArbitratorCanChangeBounty(bool _defaultArbitratorCanChangeBounty) external onlyOwner {\n        defaultArbitratorCanChangeBounty = _defaultArbitratorCanChangeBounty;\n        emit SetDefaultArbitratorCanChangeBounty(_defaultArbitratorCanChangeBounty);\n    }\n   \n    /** @notice See {IHATVaultsRegistry-setFeeSetter}. */\n    function setFeeSetter(address _feeSetter) external onlyOwner {\n        feeSetter = _feeSetter;\n        emit SetFeeSetter(_feeSetter);\n    }\n\n    /** @notice See {IHATVaultsRegistry-setWithdrawRequestParams}. */\n    function setWithdrawRequestParams(uint32 _withdrawRequestPendingPeriod, uint32  _withdrawRequestEnablePeriod)\n        external \n        onlyOwner\n    {\n        if (_withdrawRequestPendingPeriod > 90 days)\n            revert WithdrawRequestPendingPeriodTooLong();\n        if (_withdrawRequestEnablePeriod < 6 hours)\n            revert WithdrawRequestEnabledPeriodTooShort();\n        if (_withdrawRequestEnablePeriod > 100 days)\n            revert WithdrawRequestEnabledPeriodTooLong();\n        generalParameters.withdrawRequestPendingPeriod = _withdrawRequestPendingPeriod;\n        generalParameters.withdrawRequestEnablePeriod = _withdrawRequestEnablePeriod;\n        emit SetWithdrawRequestParams(_withdrawRequestPendingPeriod, _withdrawRequestEnablePeriod);\n    }\n\n    /** @notice See {IHATVaultsRegistry-setClaimFee}. */\n    function setClaimFee(uint256 _fee) external onlyOwner {\n        generalParameters.claimFee = _fee;\n        emit SetClaimFee(_fee);\n    }\n\n    /** @notice See {IHATVaultsRegistry-setWithdrawSafetyPeriod}. */\n    function setWithdrawSafetyPeriod(uint32 _withdrawPeriod, uint32 _safetyPeriod) external onlyOwner { \n        if (_withdrawPeriod < 1 hours) revert WithdrawPeriodTooShort();\n        if (_safetyPeriod > 6 hours) revert SafetyPeriodTooLong();\n        generalParameters.withdrawPeriod = _withdrawPeriod;\n        generalParameters.safetyPeriod = _safetyPeriod;\n        emit SetWithdrawSafetyPeriod(_withdrawPeriod, _safetyPeriod);\n    }\n\n    /** @notice See {IHATVaultsRegistry-setHatVestingParams}. */\n    function setHatVestingParams(uint32 _duration, uint32 _periods) external onlyOwner {\n        if (_duration >= 180 days) revert HatVestingDurationTooLong();\n        if (_periods == 0) revert HatVestingPeriodsCannotBeZero();\n        if (_duration < _periods) revert HatVestingDurationSmallerThanPeriods();\n        generalParameters.hatVestingDuration = _duration;\n        generalParameters.hatVestingPeriods = _periods;\n        emit SetHatVestingParams(_duration, _periods);\n    }\n\n    /** @notice See {IHATVaultsRegistry-setMaxBountyDelay}. */\n    function setMaxBountyDelay(uint32 _delay) external onlyOwner {\n        if (_delay < 2 days) revert DelayTooShort();\n        generalParameters.setMaxBountyDelay = _delay;\n        emit SetMaxBountyDelay(_delay);\n    }\n\n    /** @notice See {IHATVaultsRegistry-createVault}. */\n    function createVault(IHATVault.VaultInitParams calldata _params) external returns(address vault) {\n        vault = Clones.clone(hatVaultImplementation);\n\n        HATVault(vault).initialize(_params);\n\n        hatVaults.push(vault);\n\n        emit VaultCreated(vault, _params);\n    }\n\n    /** @notice See {IHATVaultsRegistry-setVaultVisibility}. */\n    function setVaultVisibility(address _vault, bool _visible) external onlyOwner {\n        isVaultVisible[_vault] = _visible;\n        emit SetVaultVisibility(_vault, _visible);\n    }\n\n    /** @notice See {IHATVaultsRegistry-addTokensToSwap}. */\n    function addTokensToSwap(\n        IERC20 _asset,\n        address _hacker,\n        uint256 _hackersHatReward,\n        uint256 _governanceHatReward\n    ) external {\n        hackersHatReward[address(_asset)][_hacker] += _hackersHatReward;\n        governanceHatReward[address(_asset)] += _governanceHatReward;\n        _asset.safeTransferFrom(msg.sender, address(this), _hackersHatReward + _governanceHatReward);\n    }\n\n    /** @notice See {IHATVaultsRegistry-swapAndSend}. */\n    function swapAndSend(\n        address _asset,\n        address[] calldata _beneficiaries,\n        uint256 _amountOutMinimum,\n        address _routingContract,\n        bytes calldata _routingPayload\n    ) external onlyOwner {\n        // Needed to avoid a \"stack too deep\" error\n        SwapData memory _swapData;\n        _swapData.hackerRewards = new uint256[](_beneficiaries.length);\n        _swapData.governanceHatReward = governanceHatReward[_asset];\n        _swapData.amount = _swapData.governanceHatReward;\n        for (uint256 i = 0; i < _beneficiaries.length;) { \n            _swapData.hackerRewards[i] = hackersHatReward[_asset][_beneficiaries[i]];\n            hackersHatReward[_asset][_beneficiaries[i]] = 0;\n            _swapData.amount += _swapData.hackerRewards[i]; \n            unchecked { ++i; }\n        }\n        if (_swapData.amount == 0) revert AmountToSwapIsZero();\n        IERC20 _HAT = HAT;\n        (_swapData.hatsReceived, _swapData.amountUnused) = _swapTokenForHAT(IERC20(_asset), _swapData.amount, _amountOutMinimum, _routingContract, _routingPayload);\n        \n        _swapData.usedPart = (_swapData.amount - _swapData.amountUnused);\n        _swapData.governanceAmountSwapped = _swapData.usedPart.mulDiv(_swapData.governanceHatReward, _swapData.amount);\n        governanceHatReward[_asset]  = _swapData.amountUnused.mulDiv(_swapData.governanceHatReward, _swapData.amount);\n\n        for (uint256 i = 0; i < _beneficiaries.length;) {\n            uint256 _hackerReward = _swapData.hatsReceived.mulDiv(_swapData.hackerRewards[i], _swapData.amount);\n            uint256 _hackerAmountSwapped = _swapData.usedPart.mulDiv(_swapData.hackerRewards[i], _swapData.amount);\n            _swapData.totalHackerReward += _hackerReward;\n            hackersHatReward[_asset][_beneficiaries[i]] = _swapData.amountUnused.mulDiv(_swapData.hackerRewards[i], _swapData.amount);\n            address _tokenLock;\n            if (_hackerReward > 0) {\n                // hacker gets her reward via vesting contract\n                _tokenLock = tokenLockFactory.createTokenLock(\n                    address(_HAT),\n                    0x0000000000000000000000000000000000000000, //this address as owner, so it can do nothing.\n                    _beneficiaries[i],\n                    _hackerReward,\n                    // solhint-disable-next-line not-rely-on-time\n                    block.timestamp, //start\n                    // solhint-disable-next-line not-rely-on-time\n                    block.timestamp + generalParameters.hatVestingDuration, //end\n                    generalParameters.hatVestingPeriods,\n                    0, // no release start\n                    0, // no cliff\n                    ITokenLock.Revocability.Disabled,\n                    true\n                );\n                _HAT.safeTransfer(_tokenLock, _hackerReward);\n            }\n            emit SwapAndSend(_beneficiaries[i], _hackerAmountSwapped, _hackerReward, _tokenLock);\n            unchecked { ++i; }\n        }\n        address _owner = owner(); \n        uint256 _amountToOwner = _swapData.hatsReceived - _swapData.totalHackerReward;\n        _HAT.safeTransfer(_owner, _amountToOwner);\n        emit SwapAndSend(_owner, _swapData.governanceAmountSwapped, _amountToOwner, address(0));\n    }\n\n    /** @notice See {IHATVaultsRegistry-getWithdrawPeriod}. */   \n      function getWithdrawPeriod() external view returns (uint256) {\n        return generalParameters.withdrawPeriod;\n    }\n\n    /** @notice See {IHATVaultsRegistry-getSafetyPeriod}. */   \n    function getSafetyPeriod() external view returns (uint256) {\n        return generalParameters.safetyPeriod;\n    }\n\n    /** @notice See {IHATVaultsRegistry-getWithdrawRequestEnablePeriod}. */   \n    function getWithdrawRequestEnablePeriod() external view returns (uint256) {\n        return generalParameters.withdrawRequestEnablePeriod;\n    }\n\n    /** @notice See {IHATVaultsRegistry-getWithdrawRequestPendingPeriod}. */   \n    function getWithdrawRequestPendingPeriod() external view returns (uint256) {\n        return generalParameters.withdrawRequestPendingPeriod;\n    }\n\n    /** @notice See {IHATVaultsRegistry-getSetMaxBountyDelay}. */   \n    function getSetMaxBountyDelay() external view returns (uint256) {\n        return generalParameters.setMaxBountyDelay;\n    }\n\n    /** @notice See {IHATVaultsRegistry-getNumberOfVaults}. */\n    function getNumberOfVaults() external view returns(uint256) {\n        return hatVaults.length;\n    }\n\n    /** @notice See {IHATVaultsRegistry-validateHATSplit}. */\n    function validateHATSplit(uint16 _bountyGovernanceHAT, uint16 _bountyHackerHATVested) public pure {\n        if (_bountyGovernanceHAT + _bountyHackerHATVested > MAX_HAT_SPLIT)\n            revert TotalHatsSplitPercentageShouldBeUpToMaxHATSplit();\n    }\n\n    /** @notice See {IHATVaultsRegistry-validateChallengePeriod}. */\n    function validateChallengePeriod(uint32 _challengePeriod) public pure {\n        if (_challengePeriod < 1 days) revert ChallengePeriodTooShort();\n        if (_challengePeriod > 5 days) revert ChallengePeriodTooLong();\n    }\n\n    /** @notice See {IHATVaultsRegistry-validateChallengeTimeOutPeriod}. */\n    function validateChallengeTimeOutPeriod(uint32 _challengeTimeOutPeriod) public pure {\n        if (_challengeTimeOutPeriod < 2 days) revert ChallengeTimeOutPeriodTooShort();\n        if (_challengeTimeOutPeriod > 85 days) revert ChallengeTimeOutPeriodTooLong();\n    }\n    \n    /**\n    * @dev Use the given routing contract to swap the given token to HAT token\n    * @param _asset The token to swap\n    * @param _amount Amount of token to swap\n    * @param _amountOutMinimum Minimum amount of HAT tokens at swap\n    * @param _routingContract Routing contract to call for the swap\n    * @param _routingPayload Payload to send to the _routingContract for the \n    * swap\n    */\n    function _swapTokenForHAT(\n        IERC20 _asset,\n        uint256 _amount,\n        uint256 _amountOutMinimum,\n        address _routingContract,\n        bytes calldata _routingPayload)\n    internal\n    returns (uint256 hatsReceived, uint256 amountUnused)\n    {\n        IERC20 _HAT = HAT;\n        if (_asset == _HAT) {\n            return (_amount, 0);\n        }\n\n        IERC20(_asset).safeApprove(_routingContract, _amount);\n        uint256 _balanceBefore = _HAT.balanceOf(address(this));\n        uint256 _assetBalanceBefore = _asset.balanceOf(address(this));\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success,) = _routingContract.call(_routingPayload);\n        if (!success) revert SwapFailed();\n        hatsReceived = _HAT.balanceOf(address(this)) - _balanceBefore;\n        amountUnused = _amount - (_assetBalanceBefore - _asset.balanceOf(address(this)));\n        if (hatsReceived < _amountOutMinimum)\n            revert AmountSwappedLessThanMinimum();\n\n        IERC20(_asset).safeApprove(address(_routingContract), 0);\n    }\n}\n"
    },
    "contracts/interfaces/IHATToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/governance/utils/IVotes.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n\ninterface IHATToken is IVotes, IERC20Permit {\n\n    // Amount for minting or burning cannot be zero\n    error ZeroAmount();\n\n    // Token transfers had not been enabled yet\n    error TransfersDisabled();\n\n    /// @notice An event thats emitted when the minter address is set\n    event MinterSet(address indexed minter, uint256 seedAmount);\n\n    /// @notice An event thats emitted when the token is set to transferable\n    event TransferableSet();\n    \n    /**\n     * @notice Set the minter address, can only be called by the owner (governance)\n     * @param _minter The address of the minter\n     * @param _seedAmount The amount of tokens to seed the minter with\n     */\n    function setMinter(address _minter, uint256 _seedAmount) external;\n\n    function burn(uint256 _amount) external;\n\n    function mint(address _account, uint _amount) external;\n\n}\n"
    },
    "contracts/interfaces/IHATVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Disclaimer https://github.com/hats-finance/hats-contracts/blob/main/DISCLAIMER.md\n\npragma solidity 0.8.16;\n\nimport \"./IRewardController.sol\";\nimport \"@openzeppelin/contracts-upgradeable/interfaces/IERC4626Upgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/** @title Interface for Hats.finance Vaults\n * @author Hats.finance\n * @notice A HATVault holds the funds for a specific project's bug bounties.\n * Anyone can permissionlessly deposit into the HATVault using\n * the vault’s native token. When a bug is submitted and approved, the bounty \n * is paid out using the funds in the vault. Bounties are paid out as a\n * percentage of the vault. The percentage is set according to the severity of\n * the bug. Vaults have regular safety periods (typically for an hour twice a\n * day) which are time for the committee to make decisions.\n *\n * In addition to the roles defined in the HATVaultsRegistry, every HATVault \n * has the roles:\n * Committee - The only address which can submit a claim for a bounty payout\n * and set the maximum bounty.\n * User - Anyone can deposit the vault's native token into the vault and \n * recieve shares for it. Shares represent the user's relative part in the\n * vault, and when a bounty is paid out, users lose part of their deposits\n * (based on percentage paid), but keep their share of the vault.\n * Users also receive rewards for their deposits, which can be claimed at any\n *  time.\n * To withdraw previously deposited tokens, a user must first send a withdraw\n * request, and the withdrawal will be made available after a pending period.\n * Withdrawals are not permitted during safety periods or while there is an \n * active claim for a bounty payout.\n *\n * Bounties are payed out distributed between a few channels, and that \n * distribution is set upon creation (the hacker gets part in direct transfer,\n * part in vested reward and part in vested HAT token, part gets rewarded to\n * the committee, part gets swapped to HAT token and burned and/or sent to Hats\n * governance).\n *\n * NOTE: Vaults should not use tokens which do not guarantee that the amount\n * specified is the amount transferred\n *\n * This project is open-source and can be found at:\n * https://github.com/hats-finance/hats-contracts\n */\ninterface IHATVault is IERC4626Upgradeable {\n\n    enum ArbitratorCanChangeBounty{ NO, YES, DEFAULT }\n\n    // How to divide the bounty - after deducting the part that is swapped to\n    // HAT tokens (and then sent to governance and vested to the hacker)\n    // values are in percentages and should add up to 100% (defined as 10000)\n    struct BountySplit {\n        // the percentage of reward sent to the hacker via vesting contract\n        uint16 hackerVested;\n        // the percentage of tokens that are sent directly to the hacker\n        uint16 hacker;\n        // the percentage sent to the committee\n        uint16 committee;\n    }\n\n    // How to divide a bounty for a claim that has been approved\n    // used to keep track of payouts, amounts are in vault's native token\n    struct ClaimBounty {\n        uint256 hacker;\n        uint256 hackerVested;\n        uint256 committee;\n        uint256 hackerHatVested;\n        uint256 governanceHat;\n    }\n\n    /**\n    * @notice Initialization parameters for the vault\n    * @param name The vault's name (concatenated as \"Hats Vault \" + name)\n    * @param symbol The vault's symbol (concatenated as \"HAT\" + symbol)\n    * @param rewardController The reward controller for the vault\n    * @param vestingDuration Duration of the vesting period of the vault's\n    * token vested part of the bounty\n    * @param vestingPeriods The number of vesting periods of the vault's token\n    * vested part of the bounty\n    * @param maxBounty The maximum percentage of the vault that can be paid\n    * out as a bounty\n    * @param bountySplit The way to split the bounty between the hacker, \n    * hacker vested, and committee.\n    *   Each entry is a number between 0 and `HUNDRED_PERCENT`.\n    *   Total splits should be equal to `HUNDRED_PERCENT`.\n    * @param asset The vault's native token\n    * @param owner The address of the vault's owner \n    * @param committee The address of the vault's committee \n    * @param isPaused Whether to initialize the vault with deposits disabled\n    * @dev Needed to avoid a \"stack too deep\" error\n    */\n    struct VaultInitParams {\n        string name;\n        string symbol;\n        IRewardController[] rewardControllers;\n        uint32 vestingDuration;\n        uint32 vestingPeriods;\n        uint16 maxBounty;\n        IHATVault.BountySplit bountySplit;\n        IERC20 asset;\n        address owner;\n        address committee;\n        bool isPaused;\n        string descriptionHash;\n    }\n\n    // Only committee\n    error OnlyCommittee();\n    // Active claim exists\n    error ActiveClaimExists();\n    // Safety period\n    error SafetyPeriod();\n    // Not safety period\n    error NotSafetyPeriod();\n    // Bounty percentage is higher than the max bounty\n    error BountyPercentageHigherThanMaxBounty();\n    // Only callable by arbitrator or after challenge timeout period\n    error OnlyCallableByArbitratorOrAfterChallengeTimeOutPeriod();\n    // No active claim exists\n    error NoActiveClaimExists();\n    // Claim Id specified is not the active claim Id\n    error ClaimIdIsNotActive();\n    // Not enough fee paid\n    error NotEnoughFeePaid();\n    // No pending max bounty\n    error NoPendingMaxBounty();\n    // Delay period for setting max bounty had not passed\n    error DelayPeriodForSettingMaxBountyHadNotPassed();\n    // Committee already checked in\n    error CommitteeAlreadyCheckedIn();\n    // Total bounty split % should be `HUNDRED_PERCENT`\n    error TotalSplitPercentageShouldBeHundredPercent();\n    // Vesting duration is too long\n    error VestingDurationTooLong();\n    // Vesting periods cannot be zero\n    error VestingPeriodsCannotBeZero();\n    // Vesting duration smaller than periods\n    error VestingDurationSmallerThanPeriods();\n    // Max bounty cannot be more than `MAX_BOUNTY_LIMIT`\n    error MaxBountyCannotBeMoreThanMaxBountyLimit();\n    // Committee bounty split cannot be more than `MAX_COMMITTEE_BOUNTY`\n    error CommitteeBountyCannotBeMoreThanMax();\n    // Only registry owner\n    error OnlyRegistryOwner();\n    // Only fee setter\n    error OnlyFeeSetter();\n    // Fee must be less than or equal to 2%\n    error WithdrawalFeeTooBig();\n    // Set shares arrays must have same length\n    error SetSharesArraysMustHaveSameLength();\n    // Committee not checked in yet\n    error CommitteeNotCheckedInYet();\n    // Not enough user balance\n    error NotEnoughUserBalance();\n    // Only arbitrator or registry owner\n    error OnlyArbitratorOrRegistryOwner();\n    // Unchalleged claim can only be approved if challenge period is over\n    error UnchallengedClaimCanOnlyBeApprovedAfterChallengePeriod();\n    // Challenged claim can only be approved by arbitrator before the challenge timeout period\n    error ChallengedClaimCanOnlyBeApprovedByArbitratorUntilChallengeTimeoutPeriod();\n    // Claim has expired\n    error ClaimExpired();\n    // Challenge period is over\n    error ChallengePeriodEnded();\n    // Claim can be challenged only once\n    error ClaimAlreadyChallenged();\n    // Only callable if challenged\n    error OnlyCallableIfChallenged();\n    // Cannot deposit to another user with withdraw request\n    error CannotTransferToAnotherUserWithActiveWithdrawRequest();\n    // Withdraw amount must be greater than zero\n    error WithdrawMustBeGreaterThanZero();\n    // Redeem amount cannot be more than maximum for user\n    error RedeemMoreThanMax();\n    // System is in an emergency pause\n    error SystemInEmergencyPause();\n    // Cannot set a reward controller that was already used in the past\n    error CannotSetToPerviousRewardController();\n    // Cannot mint burn or transfer 0 amount of shares\n    error AmountCannotBeZero();\n    // Cannot transfer shares to self\n    error CannotTransferToSelf();\n    // First deposit must return at least MINIMAL_AMOUNT_OF_SHARES\n    error AmountOfSharesMustBeMoreThanMinimalAmount();\n    // Deposit passed max slippage\n    error DepositSlippageProtection();\n    // Mint passed max slippage\n    error MintSlippageProtection();\n    // Withdraw passed max slippage\n    error WithdrawSlippageProtection();\n    // Redeem passed max slippage\n    error RedeemSlippageProtection();\n\n\n    event SubmitClaim(\n        bytes32 indexed _claimId,\n        address indexed _committee,\n        address indexed _beneficiary,\n        uint256 _bountyPercentage,\n        string _descriptionHash\n    );\n    event ChallengeClaim(bytes32 indexed _claimId);\n    event ApproveClaim(\n        bytes32 indexed _claimId,\n        address indexed _committee,\n        address indexed _beneficiary,\n        uint256 _bountyPercentage,\n        address _tokenLock,\n        ClaimBounty _claimBounty\n    );\n    event DismissClaim(bytes32 indexed _claimId);\n    event SetCommittee(address indexed _committee);\n    event SetVestingParams(\n        uint256 _duration,\n        uint256 _periods\n    );\n    event SetBountySplit(BountySplit _bountySplit);\n    event SetWithdrawalFee(uint256 _newFee);\n    event CommitteeCheckedIn();\n    event SetPendingMaxBounty(uint256 _maxBounty);\n    event SetMaxBounty(uint256 _maxBounty);\n    event AddRewardController(IRewardController indexed _newRewardController);\n    event SetDepositPause(bool _depositPause);\n    event SetVaultDescription(string _descriptionHash);\n    event SetHATBountySplit(uint256 _bountyGovernanceHAT, uint256 _bountyHackerHATVested);\n    event SetArbitrator(address indexed _arbitrator);\n    event SetChallengePeriod(uint256 _challengePeriod);\n    event SetChallengeTimeOutPeriod(uint256 _challengeTimeOutPeriod);\n    event SetArbitratorCanChangeBounty(ArbitratorCanChangeBounty _arbitratorCanChangeBounty);\n    event WithdrawRequest(\n        address indexed _beneficiary,\n        uint256 _withdrawEnableTime\n    );\n\n    /**\n    * @notice Initialize a vault instance\n    * @param _params The vault initialization parameters\n    * @dev See {IHATVault-VaultInitParams} for more details\n    * @dev Called when the vault is created in {IHATVaultsRegistry-createVault}\n    */\n    function initialize(VaultInitParams calldata _params) external;\n\n    /* -------------------------------------------------------------------------------- */\n\n    /* ---------------------------------- Claim --------------------------------------- */\n\n    /**\n     * @notice Called by the committee to submit a claim for a bounty payout.\n     * This function should be called only on a safety period, when withdrawals\n     * are disabled, and while there's no other active claim. Cannot be called\n     * when the registry is in an emergency pause.\n     * Upon a call to this function by the committee the vault's withdrawals\n     * will be disabled until the claim is approved or dismissed. Also from the\n     * time of this call the arbitrator will have a period of \n     * {HATVaultsRegistry.challengePeriod} to challenge the claim.\n     * @param _beneficiary The submitted claim's beneficiary\n     * @param _bountyPercentage The submitted claim's bug requested reward percentage\n     */\n    function submitClaim(\n        address _beneficiary, \n        uint16 _bountyPercentage, \n        string calldata _descriptionHash\n    )\n        external\n        returns (bytes32 claimId);\n\n   \n    /**\n    * @notice Called by the arbitrator or governance to challenge a claim for a bounty\n    * payout that had been previously submitted by the committee.\n    * Can only be called during the challenge period after submission of the\n    * claim.\n    * @param _claimId The claim ID\n    */\n    function challengeClaim(bytes32 _claimId) external;\n\n    /**\n    * @notice Approve a claim for a bounty submitted by a committee, and\n    * pay out bounty to hacker and committee. Also transfer to the \n    * HATVaultsRegistry the part of the bounty that will be swapped to HAT \n    * tokens.\n    * If the claim had been previously challenged, this is only callable by\n    * the arbitrator. Otherwise, callable by anyone after challengePeriod had\n    * passed.\n    * @param _claimId The claim ID\n    * @param _bountyPercentage The percentage of the vault's balance that will\n    * be sent as a bounty. This value will be ignored if the caller is not the\n    * arbitrator.\n    */\n    function approveClaim(bytes32 _claimId, uint16 _bountyPercentage)\n        external;\n\n    /**\n    * @notice Dismiss the active claim for bounty payout submitted by the\n    * committee.\n    * Called either by the arbitrator, or by anyone if the claim has timed out.\n    * @param _claimId The claim ID\n    */\n    function dismissClaim(bytes32 _claimId) external;\n\n    /* -------------------------------------------------------------------------------- */\n\n    /* ---------------------------------- Params -------------------------------------- */\n\n    /**\n    * @notice Set new committee address. Can be called by existing committee,\n    * or by the the vault's owner in the case that the committee hadn't checked in\n    * yet.\n    * @param _committee The address of the new committee \n    */\n    function setCommittee(address _committee) external;\n\n    /**\n    * @notice Called by the vault's owner to set the vesting params for the\n    * part of the bounty that the hacker gets vested in the vault's native\n    * token\n    * @param _duration Duration of the vesting period. Must be smaller than\n    * 120 days and bigger than `_periods`\n    * @param _periods Number of vesting periods. Cannot be 0.\n    */\n    function setVestingParams(uint32 _duration, uint32 _periods) external;\n\n    /**\n    * @notice Called by the vault's owner to set the vault token bounty split\n    * upon an approval.\n    * Can only be called if is no active claim and not during safety periods.\n    * @param _bountySplit The bounty split\n    */\n    function setBountySplit(BountySplit calldata _bountySplit) external;\n\n    /**\n    * @notice Called by the registry's fee setter to set the fee for \n    * withdrawals from the vault.\n    * @param _fee The new fee. Must be smaller than or equal to `MAX_WITHDRAWAL_FEE`\n    */\n    function setWithdrawalFee(uint256 _fee) external;\n\n    /**\n    * @notice Called by the vault's committee to claim it's role.\n    * Deposits are enabled only after committee check in.\n    */\n    function committeeCheckIn() external;\n\n    /**\n    * @notice Called by the vault's owner to set a pending request for the\n    * maximum percentage of the vault that can be paid out as a bounty.\n    * Cannot be called if there is an active claim that has been submitted.\n    * Max bounty should be less than or equal to 90% (defined as 9000).\n    * The pending value can be set by the owner after the time delay (of \n    * {HATVaultsRegistry.generalParameters.setMaxBountyDelay}) had passed.\n    * @param _maxBounty The maximum bounty percentage that can be paid out\n    */\n    function setPendingMaxBounty(uint16 _maxBounty) external;\n\n    /**\n    * @notice Called by the vault's owner to set the vault's max bounty to\n    * the already pending max bounty.\n    * Cannot be called if there are active claims that have been submitted.\n    * Can only be called if there is a max bounty pending approval, and the\n    * time delay since setting the pending max bounty had passed.\n    */\n    function setMaxBounty() external;\n\n    /**\n    * @notice Called by the vault's owner to disable all deposits to the vault\n    * @param _depositPause Are deposits paused\n    */\n    function setDepositPause(bool _depositPause) external;\n\n    /**\n    * @notice Called by the registry's owner to change the description of the\n    * vault in the Hats.finance UI\n    * @param _descriptionHash the hash of the vault's description\n    */\n    function setVaultDescription(string calldata _descriptionHash) external;\n\n    /**\n    * @notice Called by the registry's owner to add a reward controller to the vault\n    * @param _newRewardController The new reward controller to add\n    */\n    function addRewardController(IRewardController _newRewardController) external;\n\n    /**\n    * @notice Called by the registry's owner to set the vault HAT token bounty \n    * split upon an approval.\n    * If the value passed is the special \"null\" value the vault will use the\n    * registry's default value.\n    * @param _bountyGovernanceHAT The HAT bounty for governance\n    * @param _bountyHackerHATVested The HAT bounty vested for the hacker\n    */\n    function setHATBountySplit(\n        uint16 _bountyGovernanceHAT,\n        uint16 _bountyHackerHATVested\n    ) \n        external;\n\n    /**\n    * @notice Called by the registry's owner to set the vault arbitrator\n    * If the value passed is the special \"null\" value the vault will use the\n    * registry's default value.\n    * @param _arbitrator The address of vault's arbitrator\n    */\n    function setArbitrator(address _arbitrator) external;\n\n    /**\n    * @notice Called by the registry's owner to set the period of time after\n    * a claim for a bounty payout has been submitted that it can be challenged\n    * by the arbitrator.\n    * If the value passed is the special \"null\" value the vault will use the\n    * registry's default value.\n    * @param _challengePeriod The vault's challenge period\n    */\n    function setChallengePeriod(uint32 _challengePeriod) external;\n\n    /**\n    * @notice Called by the registry's owner to set the period of time after\n    * which a claim for a bounty payout can be dismissed by anyone.\n    * If the value passed is the special \"null\" value the vault will use the\n    * registry's default value.\n    * @param _challengeTimeOutPeriod The vault's challenge timeout period\n    */\n    function setChallengeTimeOutPeriod(uint32 _challengeTimeOutPeriod)\n        external;\n\n    /**\n    * @notice Called by the registry's owner to set whether the arbitrator\n    * can change a claim bounty percentage\n    * If the value passed is the special \"null\" value the vault will use the\n    * registry's default value.\n    * @param _arbitratorCanChangeBounty Whether the arbitrator can change a claim bounty percentage\n    */\n    function setArbitratorCanChangeBounty(ArbitratorCanChangeBounty _arbitratorCanChangeBounty) external;\n\n    /* -------------------------------------------------------------------------------- */\n\n    /* ---------------------------------- Vault --------------------------------------- */\n\n    /**\n    * @notice Submit a request to withdraw funds from the vault.\n    * The request will only be approved if there is no previous active\n    * withdraw request.\n    * The request will be pending for a period of\n    * {HATVaultsRegistry.generalParameters.withdrawRequestPendingPeriod},\n    * after which a withdraw will be possible for a duration of\n    * {HATVaultsRegistry.generalParameters.withdrawRequestEnablePeriod}\n    */\n    function withdrawRequest() external;\n\n    /** \n    * @notice Withdraw previously deposited funds from the vault and claim\n    * the HAT reward that the user has earned.\n    * Can only be performed if a withdraw request has been previously\n    * submitted, and the pending period had passed, and while the withdraw\n    * enabled timeout had not passed. Withdrawals are not permitted during\n    * safety periods or while there is an active claim for a bounty payout.\n    * @param assets Amount of tokens to withdraw\n    * @param receiver Address of receiver of the funds\n    * @param owner Address of owner of the funds\n    * @dev See {IERC4626-withdraw}.\n    */\n    function withdrawAndClaim(uint256 assets, address receiver, address owner)\n        external \n        returns (uint256 shares);\n\n    /** \n    * @notice Redeem shares in the vault for the respective amount\n    * of underlying assets and claim the HAT reward that the user has earned.\n    * Can only be performed if a withdraw request has been previously\n    * submitted, and the pending period had passed, and while the withdraw\n    * enabled timeout had not passed. Withdrawals are not permitted during\n    * safety periods or while there is an active claim for a bounty payout.\n    * @param shares Amount of shares to redeem\n    * @param receiver Address of receiver of the funds \n    * @param owner Address of owner of the funds \n    * @dev See {IERC4626-redeem}.\n    */\n    function redeemAndClaim(uint256 shares, address receiver, address owner)\n        external \n        returns (uint256 assets);\n\n    /** \n    * @notice Redeem all of the user's shares in the vault for the respective amount\n    * of underlying assets without calling the reward controller, meaning user renounces\n    * their uncommited part of the reward.\n    * Can only be performed if a withdraw request has been previously\n    * submitted, and the pending period had passed, and while the withdraw\n    * enabled timeout had not passed. Withdrawals are not permitted during\n    * safety periods or while there is an active claim for a bounty payout.\n    * @param receiver Address of receiver of the funds \n    */\n    function emergencyWithdraw(address receiver) external returns (uint256 assets);\n\n    /** \n    * @notice Withdraw previously deposited funds from the vault, without\n    * transferring the accumulated rewards.\n    * Can only be performed if a withdraw request has been previously\n    * submitted, and the pending period had passed, and while the withdraw\n    * enabled timeout had not passed. Withdrawals are not permitted during\n    * safety periods or while there is an active claim for a bounty payout.\n    * @param assets Amount of tokens to withdraw\n    * @param receiver Address of receiver of the funds \n    * @param owner Address of owner of the funds \n    * @dev See {IERC4626-withdraw}.\n    */\n    function withdraw(uint256 assets, address receiver, address owner)\n        external \n        returns (uint256);\n\n    /** \n    * @notice Redeem shares in the vault for the respective amount\n    * of underlying assets, without transferring the accumulated reward.\n    * Can only be performed if a withdraw request has been previously\n    * submitted, and the pending period had passed, and while the withdraw\n    * enabled timeout had not passed. Withdrawals are not permitted during\n    * safety periods or while there is an active claim for a bounty payout.\n    * @param shares Amount of shares to redeem\n    * @param receiver Address of receiver of the funds \n    * @param owner Address of owner of the funds \n    * @dev See {IERC4626-redeem}.\n    */\n    function redeem(uint256 shares, address receiver, address owner)\n        external  \n        returns (uint256);\n\n    /**\n    * @dev Deposit funds to the vault. Can only be called if the committee had\n    * checked in and deposits are not paused, and the registry is not in an emergency pause.\n    * @param receiver Reciever of the shares from the deposit\n    * @param assets Amount of vault's native token to deposit\n    * @dev See {IERC4626-deposit}.\n    */\n    function deposit(uint256 assets, address receiver) \n        external\n        returns (uint256);\n\n    /**\n    * @dev Deposit funds to the vault. Can only be called if the committee had\n    * checked in and deposits are not paused, and the registry is not in an emergency pause.\n    * Allows to specify minimum shares to be minted for slippage protection.\n    * @param receiver Reciever of the shares from the deposit\n    * @param assets Amount of vault's native token to deposit\n    * @param minShares Minimum amount of shares to minted for the assets\n    */\n    function deposit(uint256 assets, address receiver, uint256 minShares) \n        external\n        returns (uint256);\n\n    /**\n    * @dev Deposit funds to the vault based on the amount of shares to mint specified.\n    * Can only be called if the committee had checked in and deposits are not paused,\n    * and the registry is not in an emergency pause.\n    * Allows to specify maximum assets to be deposited for slippage protection.\n    * @param receiver Reciever of the shares from the deposit\n    * @param shares Amount of vault's shares to mint\n    * @param maxAssets Maximum amount of assets to deposit for the shares\n    */\n    function mint(uint256 shares, address receiver, uint256 maxAssets) \n        external\n        returns (uint256);\n\n    /** \n    * @notice Withdraw previously deposited funds from the vault, without\n    * transferring the accumulated HAT reward.\n    * Can only be performed if a withdraw request has been previously\n    * submitted, and the pending period had passed, and while the withdraw\n    * enabled timeout had not passed. Withdrawals are not permitted during\n    * safety periods or while there is an active claim for a bounty payout.\n    * Allows to specify maximum shares to be burnt for slippage protection.\n    * @param assets Amount of tokens to withdraw\n    * @param receiver Address of receiver of the funds \n    * @param owner Address of owner of the funds\n    * @param maxShares Maximum amount of shares to burn for the assets\n    */\n    function withdraw(uint256 assets, address receiver, address owner, uint256 maxShares)\n        external \n        returns (uint256);\n\n    /** \n    * @notice Redeem shares in the vault for the respective amount\n    * of underlying assets, without transferring the accumulated reward.\n    * Can only be performed if a withdraw request has been previously\n    * submitted, and the pending period had passed, and while the withdraw\n    * enabled timeout had not passed. Withdrawals are not permitted during\n    * safety periods or while there is an active claim for a bounty payout.\n    * Allows to specify minimum assets to be received for slippage protection.\n    * @param shares Amount of shares to redeem\n    * @param receiver Address of receiver of the funds \n    * @param owner Address of owner of the funds\n    * @param minAssets Minimum amount of assets to receive for the shares\n    */\n    function redeem(uint256 shares, address receiver, address owner, uint256 minAssets)\n        external  \n        returns (uint256);\n\n    /** \n    * @notice Withdraw previously deposited funds from the vault and claim\n    * the HAT reward that the user has earned.\n    * Can only be performed if a withdraw request has been previously\n    * submitted, and the pending period had passed, and while the withdraw\n    * enabled timeout had not passed. Withdrawals are not permitted during\n    * safety periods or while there is an active claim for a bounty payout.\n    * Allows to specify maximum shares to be burnt for slippage protection.\n    * @param assets Amount of tokens to withdraw\n    * @param receiver Address of receiver of the funds\n    * @param owner Address of owner of the funds\n    * @param maxShares Maximum amount of shares to burn for the assets\n    * @dev See {IERC4626-withdraw}.\n    */\n    function withdrawAndClaim(uint256 assets, address receiver, address owner, uint256 maxShares)\n        external \n        returns (uint256 shares);\n\n    /** \n    * @notice Redeem shares in the vault for the respective amount\n    * of underlying assets and claim the HAT reward that the user has earned.\n    * Can only be performed if a withdraw request has been previously\n    * submitted, and the pending period had passed, and while the withdraw\n    * enabled timeout had not passed. Withdrawals are not permitted during\n    * safety periods or while there is an active claim for a bounty payout.\n    * Allows to specify minimum assets to be received for slippage protection.\n    * @param shares Amount of shares to redeem\n    * @param receiver Address of receiver of the funds \n    * @param owner Address of owner of the funds\n    * @param minAssets Minimum amount of assets to receive for the shares\n    * @dev See {IERC4626-redeem}.\n    */\n    function redeemAndClaim(uint256 shares, address receiver, address owner, uint256 minAssets)\n        external \n        returns (uint256 assets);\n\n    /* -------------------------------------------------------------------------------- */\n\n    /* --------------------------------- Getters -------------------------------------- */\n\n    /** \n    * @notice Returns the vault HAT bounty split part that goes to the governance\n    * If no specific value for this vault has been set, the registry's default\n    * value will be returned.\n    * @return The vault's HAT bounty split part that goes to the governance\n    */\n    function getBountyGovernanceHAT() external view returns(uint16);\n    \n    /** \n    * @notice Returns the vault HAT bounty split part that is vested for the hacker\n    * If no specific value for this vault has been set, the registry's default\n    * value will be returned.\n    * @return The vault's HAT bounty split part that is vested for the hacker\n    */\n    function getBountyHackerHATVested() external view returns(uint16);\n\n    /** \n    * @notice Returns the address of the vault's arbitrator\n    * If no specific value for this vault has been set, the registry's default\n    * value will be returned.\n    * @return The address of the vault's arbitrator\n    */\n    function getArbitrator() external view returns(address);\n\n    /** \n    * @notice Returns the period of time after a claim for a bounty payout has\n    * been submitted that it can be challenged by the arbitrator.\n    * If no specific value for this vault has been set, the registry's default\n    * value will be returned.\n    * @return The vault's challenge period\n    */\n    function getChallengePeriod() external view returns(uint32);\n\n    /** \n    * @notice Returns the period of time after which a claim for a bounty\n    * payout can be dismissed by anyone.\n    * If no specific value for this vault has been set, the registry's default\n    * value will be returned.\n    * @return The vault's challenge timeout period\n    */\n    function getChallengeTimeOutPeriod() external view returns(uint32);\n\n    /** \n    * @notice Returns the amount of shares to be burned to give the user the exact\n    * amount of assets requested plus cover for the fee. Also returns the amount assets\n    * to be paid as fee.\n    * @return shares The amount of shares to be burned to get the requested amount of assets\n    * @return fee The amount of assets that will be paid as fee\n    */\n    function previewWithdrawAndFee(uint256 assets) external view returns (uint256 shares, uint256 fee);\n\n\n    /** \n    * @notice Returns the amount of assets to be sent to the user for the exact\n    * amount of shares to redeem. Also returns the amount assets to be paid as fee.\n    * @return assets amount of assets to be sent in exchange for the amount of shares specified\n    * @return fee The amount of assets that will be paid as fee\n    */\n    function previewRedeemAndFee(uint256 shares) external view returns (uint256 assets, uint256 fee);\n}\n"
    },
    "contracts/interfaces/IHATVaultsData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ninterface IHATVaultsData {\n    \n    function getTotalShares(uint256 _pid) external view returns (uint256 totalShares);\n\n    function getShares(uint256 _pid, address _user) external view returns (uint256 shares);\n}\n"
    },
    "contracts/interfaces/IHATVaultsRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Disclaimer https://github.com/hats-finance/hats-contracts/blob/main/DISCLAIMER.md\n\npragma solidity 0.8.16;\n\nimport \"./IHATVault.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/** @title Interface for the Hats.finance Vault Registry\n * @author hats.finance\n * @notice The Hats.finance Vault Registry is used to deploy Hats.finance\n * vaults and manage shared parameters.\n *\n * Hats.finance is a proactive bounty protocol for white hat hackers and\n * security experts, where projects, community members, and stakeholders\n * incentivize protocol security and responsible disclosure.\n * Hats create scalable vaults using the project’s own token. The value of the\n * bounty increases with the success of the token and project.\n *\n * The owner of the registry has the permission to set time limits and bounty\n * parameters and change vaults' info, and to set the other registry roles -\n * fee setter and arbitrator.\n * The arbitrator can challenge submitted claims for bounty payouts made by\n * vaults' committees, approve them with a different bounty percentage or\n * dismiss them.\n * The fee setter can set the fee on withdrawals on all vaults.\n *\n * This project is open-source and can be found at:\n * https://github.com/hats-finance/hats-contracts\n *\n * @dev New hats.finance vaults should be created through a call to {createVault}\n * so that they are linked to the registry\n */\ninterface IHATVaultsRegistry {\n\n    // a struct with parameters for all vaults\n    struct GeneralParameters {\n        // vesting duration for the part of the bounty given to the hacker in HAT tokens\n        uint32 hatVestingDuration;\n        // vesting periods for the part of the bounty given to the hacker in HAT tokens\n        uint32 hatVestingPeriods;\n        // withdraw enable period. safetyPeriod starts when finished.\n        uint32 withdrawPeriod;\n        // withdraw disable period - time for the committee to gather and decide on actions,\n        // withdrawals are not possible in this time. withdrawPeriod starts when finished.\n        uint32 safetyPeriod;\n        // period of time after withdrawRequestPendingPeriod where it is possible to withdraw\n        // (after which withdrawals are not possible)\n        uint32 withdrawRequestEnablePeriod;\n        // period of time that has to pass after withdraw request until withdraw is possible\n        uint32 withdrawRequestPendingPeriod;\n        // period of time that has to pass after setting a pending max\n        // bounty before it can be set as the new max bounty\n        uint32 setMaxBountyDelay;\n        // fee in ETH to be transferred with every logging of a claim\n        uint256 claimFee;\n    }\n\n    /**\n     * @notice Raised on {setWithdrawSafetyPeriod} if the withdraw period to\n     * be set is shorter than 1 hour\n     */\n    error WithdrawPeriodTooShort();\n\n    /**\n     * @notice Raised on {setWithdrawSafetyPeriod} if the safety period to\n     * be set is longer than 6 hours\n     */\n    error SafetyPeriodTooLong();\n\n    /**\n     * @notice Raised on {setWithdrawRequestParams} if the withdraw request\n     * pending period to be set is shorter than 3 months\n     */\n    error WithdrawRequestPendingPeriodTooLong();\n\n    /**\n     * @notice Raised on {setWithdrawRequestParams} if the withdraw request\n     * enabled period to be set is shorter than 6 hours\n     */\n    error WithdrawRequestEnabledPeriodTooShort();\n\n    /**\n     * @notice Raised on {setWithdrawRequestParams} if the withdraw request\n     * enabled period to be set is longer than 100 days\n     */\n    error WithdrawRequestEnabledPeriodTooLong();\n\n    /**\n     * @notice Raised on {setHatVestingParams} if the vesting duration to be\n     * set is longer than 180 days\n     */\n    error HatVestingDurationTooLong();\n\n    /**\n     * @notice Raised on {setHatVestingParams} if the vesting periods to be\n     * set is 0\n     */\n    error HatVestingPeriodsCannotBeZero();\n    \n    /**\n     * @notice Raised on {setHatVestingParams} if the vesting duration is \n     * smaller than the vesting periods\n     */\n    error HatVestingDurationSmallerThanPeriods();\n\n    /**\n     * @notice Raised on {setMaxBountyDelay} if the max bounty to be set is\n     * shorter than 2 days\n     */\n    error DelayTooShort();\n\n    /**\n     * @notice Raised on {swapAndSend} if the amount to swap is zero\n     */\n    error AmountToSwapIsZero();\n\n    /**\n     * @notice Raised on {swapAndSend} if the swap was not successful\n     */\n    error SwapFailed();\n    // Wrong amount received\n\n    /**\n     * @notice Raised on {swapAndSend} if the amount that was recieved in\n     * the swap was less than the minimum amount specified\n     */\n    error AmountSwappedLessThanMinimum();\n\n    /**\n     * @notice Raised on {setDefaultHATBountySplit} if the split to be set is\n     * greater than 20% (defined as 2000)\n     */\n    error TotalHatsSplitPercentageShouldBeUpToMaxHATSplit();\n\n    /**\n     * @notice Raised on {setDefaultChallengePeriod} if the challenge period\n     *  to be set is shorter than 1 day\n     */\n    error ChallengePeriodTooShort();\n\n    /**\n     * @notice Raised on {setDefaultChallengePeriod} if the challenge period\n     *  to be set is longer than 5 days\n     */\n    error ChallengePeriodTooLong();\n        \n    /**\n     * @notice Raised on {setDefaultChallengeTimeOutPeriod} if the challenge\n     * timeout period to be set is shorter than 1 day\n     */\n    error ChallengeTimeOutPeriodTooShort();\n\n    /**\n     * @notice Raised on {setDefaultChallengeTimeOutPeriod} if the challenge\n     * timeout period to be set is longer than 85 days\n     */\n    error ChallengeTimeOutPeriodTooLong();\n    \n    /**\n     * @notice Raised on {LogClaim} if the transaction was not sent with the\n     * amount of ETH specified as {generalParameters.claimFee}\n     */\n    error NotEnoughFeePaid();\n\n    /**\n     * @notice Raised on {LogClaim} if the transfer of the claim fee failed\n     */\n    error ClaimFeeTransferFailed();\n\n    /**\n     * @notice Emitted on deployment of the registry\n     * @param _hatVaultImplementation The HATVault implementation address\n     * @param _HAT The HAT token address\n     * @param _tokenLockFactory The token lock factory address\n     * @param _generalParameters The registry's general parameters\n     * @param _bountyGovernanceHAT The HAT bounty for governance\n     * @param _bountyHackerHATVested The HAT bounty vested for the hacker\n     * @param _hatGovernance The registry's governance\n     * @param _defaultChallengePeriod The new default challenge period\n     * @param _defaultChallengeTimeOutPeriod The new default challenge timeout\n     * @param _defaultArbitratorCanChangeBounty Whether the arbitrator can change bounty percentage of claims\n     */\n    event RegistryCreated(\n        address _hatVaultImplementation,\n        address _HAT,\n        address _tokenLockFactory,\n        GeneralParameters _generalParameters,\n        uint256 _bountyGovernanceHAT,\n        uint256 _bountyHackerHATVested,\n        address _hatGovernance,\n        address _defaultArbitrator,\n        uint256 _defaultChallengePeriod,\n        uint256 _defaultChallengeTimeOutPeriod,\n        bool _defaultArbitratorCanChangeBounty\n    );\n\n    /**\n     * @notice Emitted when a claim is logged\n     * @param _claimer The address of the claimer\n     * @param _descriptionHash - a hash of an ipfs encrypted file which\n     * describes the claim.\n     */\n    event LogClaim(address indexed _claimer, string _descriptionHash);\n\n    /**\n     * @notice Emitted when a new fee setter is set\n     * @param _feeSetter The address of the new fee setter\n     */\n    event SetFeeSetter(address indexed _feeSetter);\n\n    /**\n     * @notice Emitted when new withdraw request time limits are set\n     * @param _withdrawRequestPendingPeriod Time period where the withdraw\n     * request is pending\n     * @param _withdrawRequestEnablePeriod Time period after the peding period\n     * has ended during which withdrawal is enabled\n     */\n    event SetWithdrawRequestParams(\n        uint256 _withdrawRequestPendingPeriod,\n        uint256 _withdrawRequestEnablePeriod\n    );\n\n    /**\n     * @notice Emitted when a new fee for logging a claim for a bounty is set\n     * @param _fee Claim fee in ETH to be transferred on any call of {logClaim}\n     */\n    event SetClaimFee(uint256 _fee);\n\n    /**\n     * @notice Emitted when new durations are set for withdraw period and\n     * safety period\n     * @param _withdrawPeriod Amount of time during which withdrawals are\n     * enabled, and the bounty split can be changed by the governance\n     * @param _safetyPeriod Amount of time during which claims for bounties \n     * can be submitted and withdrawals are disabled\n     */\n    event SetWithdrawSafetyPeriod(\n        uint256 _withdrawPeriod,\n        uint256 _safetyPeriod\n    );\n\n    /**\n     * @notice Emitted when new HAT vesting parameters are set\n     * @param _duration The duration of the vesting period\n     * @param _periods The number of vesting periods\n     */\n    event SetHatVestingParams(uint256 _duration, uint256 _periods);\n\n    /**\n     * @notice Emitted when a new timelock delay for setting the\n     * max bounty is set\n     * @param _delay The time period for the delay\n     */\n    event SetMaxBountyDelay(uint256 _delay);\n\n    /**\n     * @notice Emitted when the UI visibility of a vault is changed\n     * @param _vault The address of the vault to update\n     * @param _visible Is this vault visible in the UI\n     */\n    event SetVaultVisibility(address indexed _vault, bool indexed _visible);\n\n    /** @dev Emitted when a new vault is created\n     * @param _vault The address of the vault to add to the registry\n     * @param _params The vault initialization parameters\n     */\n    event VaultCreated(address indexed _vault, IHATVault.VaultInitParams _params);\n    \n    /** @notice Emitted when a swap of vault tokens to HAT tokens is done and\n     * the HATS tokens are sent to beneficiary through vesting contract\n     * @param _beneficiary Address of beneficiary\n     * @param _amountSwapped Amount of vault's native tokens that was swapped\n     * @param _amountSent Amount of HAT tokens sent to beneficiary\n     * @param _tokenLock Address of the token lock contract that holds the HAT\n     * tokens (address(0) if no token lock is used)\n     */\n    event SwapAndSend(\n        address indexed _beneficiary,\n        uint256 _amountSwapped,\n        uint256 _amountSent,\n        address indexed _tokenLock\n    );\n\n    /**\n     * @notice Emitted when a new default HAT bounty split is set\n     * @param _defaultBountyGovernanceHAT The new default HAT bounty part sent to governance\n     * @param _defaultBountyHackerHATVested The new default HAT bounty part vseted for the hacker\n     */\n    event SetDefaultHATBountySplit(uint256 _defaultBountyGovernanceHAT, uint256 _defaultBountyHackerHATVested);\n\n    /**\n     * @notice Emitted when a new default arbitrator is set\n     * @param _defaultArbitrator The address of the new arbitrator\n     */\n    event SetDefaultArbitrator(address indexed _defaultArbitrator);\n\n    /**\n     * @notice Emitted when a new default challenge period is set\n     * @param _defaultChallengePeriod The new default challenge period\n     */ \n    event SetDefaultChallengePeriod(uint256 _defaultChallengePeriod);\n\n    /**\n     * @notice Emitted when a new default challenge timeout period is set\n     * @param _defaultChallengeTimeOutPeriod The new default challenge timeout\n     * period\n     */\n    event SetDefaultChallengeTimeOutPeriod(uint256 _defaultChallengeTimeOutPeriod);\n\n    /**\n     * @notice Emitted when the default arbitrator can change bounty is set\n     * @param _defaultArbitratorCanChangeBounty Whether the arbitrator can change bounty of claims\n     */\n    event SetDefaultArbitratorCanChangeBounty(bool _defaultArbitratorCanChangeBounty);\n\n    /** @notice Emitted when the system is put into emergency pause/unpause\n     * @param _isEmergencyPaused Is the system in an emergency pause\n     */\n    event SetEmergencyPaused(bool _isEmergencyPaused);\n\n    /**\n     * @notice Emitted when a new swap token is set\n     * @param _swapToken The new swap token address\n     */\n    event SetSwapToken(address indexed _swapToken);\n\n    /**\n     * @notice Called by governance to pause/unpause the system in case of an\n     * emergency\n     * @param _isEmergencyPaused Is the system in an emergency pause\n     */\n    function setEmergencyPaused(bool _isEmergencyPaused) external;\n\n    /**\n     * @notice Called by governance to set a new swap token\n     * @param _swapToken the new swap token address\n     */\n    function setSwapToken(address _swapToken) external;\n\n    /**\n     * @notice Emit an event that includes the given _descriptionHash\n     * This can be used by the claimer as evidence that she had access to the\n     * information at the time of the call\n     * if a {generalParameters.claimFee} > 0, the caller must send that amount\n     * of ETH for the claim to succeed\n     * @param _descriptionHash - a hash of an IPFS encrypted file which \n     * describes the claim.\n     */\n    function logClaim(string calldata _descriptionHash) external payable;\n\n    /**\n     * @notice Called by governance to set the default percentage of each claim bounty\n     * that will be swapped for hats and sent to the governance or vested for the hacker\n     * @param _defaultBountyGovernanceHAT The HAT bounty for governance\n     * @param _defaultBountyHackerHATVested The HAT bounty vested for the hacker\n     */\n    function setDefaultHATBountySplit(\n        uint16 _defaultBountyGovernanceHAT,\n        uint16 _defaultBountyHackerHATVested\n    ) \n        external;\n\n    /** \n     * @dev Check that a given hats bounty split is legal, meaning that:\n     *   Each entry is a number between 0 and less than `MAX_HAT_SPLIT`.\n     *   Total splits should be less than `MAX_HAT_SPLIT`.\n     * function will revert in case the bounty split is not legal.\n     * @param _bountyGovernanceHAT The HAT bounty for governance\n     * @param _bountyHackerHATVested The HAT bounty vested for the hacker\n     */\n    function validateHATSplit(uint16 _bountyGovernanceHAT, uint16 _bountyHackerHATVested)\n         external\n         pure;\n\n    /**\n     * @notice Called by governance to set the default arbitrator.\n     * @param _defaultArbitrator The default arbitrator address\n     */\n    function setDefaultArbitrator(address _defaultArbitrator) external;\n\n    /**\n     * @notice Called by governance to set the default challenge period\n     * @param _defaultChallengePeriod The default challenge period\n     */\n    function setDefaultChallengePeriod(uint32 _defaultChallengePeriod) \n        external;\n\n    /**\n     * @notice Called by governance to set the default challenge timeout\n     * @param _defaultChallengeTimeOutPeriod The Default challenge timeout\n     */\n    function setDefaultChallengeTimeOutPeriod(\n        uint32 _defaultChallengeTimeOutPeriod\n    ) \n        external;\n\n    /**\n     * @notice Called by governance to set Whether the arbitrator can change bounty of claims.\n     * @param _defaultArbitratorCanChangeBounty The default for whether the arbitrator can change bounty of claims\n     */\n    function setDefaultArbitratorCanChangeBounty(bool _defaultArbitratorCanChangeBounty) external;\n\n    /**\n     * @notice Check that the given challenge period is legal, meaning that it\n     * is greater than 1 day and less than 5 days.\n     * @param _challengePeriod The challenge period to check\n     */\n    function validateChallengePeriod(uint32 _challengePeriod) external pure;\n\n    /**\n     * @notice Check that the given challenge timeout period is legal, meaning\n     * that it is greater than 2 days and less than 85 days.\n     * @param _challengeTimeOutPeriod The challenge timeout period to check\n     */\n    function validateChallengeTimeOutPeriod(uint32 _challengeTimeOutPeriod) external pure;\n   \n    /**\n     * @notice Called by governance to set the fee setter role\n     * @param _feeSetter Address of new fee setter\n     */\n    function setFeeSetter(address _feeSetter) external;\n\n    /**\n     * @notice Called by governance to set time limits for withdraw requests\n     * @param _withdrawRequestPendingPeriod Time period where the withdraw\n     * request is pending\n     * @param _withdrawRequestEnablePeriod Time period after the peding period\n     * has ended during which withdrawal is enabled\n     */\n    function setWithdrawRequestParams(\n        uint32 _withdrawRequestPendingPeriod,\n        uint32  _withdrawRequestEnablePeriod\n    )\n        external;\n\n    /**\n     * @notice Called by governance to set the fee for logging a claim for a\n     * bounty in any vault.\n     * @param _fee Claim fee in ETH to be transferred on any call of\n     * {logClaim}\n     */\n    function setClaimFee(uint256 _fee) external;\n\n    /**\n     * @notice Called by governance to set the withdraw period and safety\n     * period, which are always interchanging.\n     * The safety period is time that the committee can submit claims for \n     * bounty payouts, and during which withdrawals are disabled and the\n     * bounty split cannot be changed.\n     * @param _withdrawPeriod Amount of time during which withdrawals are\n     * enabled, and the bounty split can be changed by the governance. Must be\n     * at least 1 hour.\n     * @param _safetyPeriod Amount of time during which claims for bounties \n     * can be submitted and withdrawals are disabled. Must be at most 6 hours.\n     */\n    function setWithdrawSafetyPeriod(\n        uint32 _withdrawPeriod,\n        uint32 _safetyPeriod\n    ) \n        external;\n\n    /**\n     * @notice Called by governance to set vesting params for rewarding hackers\n     * with rewardToken, for all vaults\n     * @param _duration Duration of the vesting period. Must be less than 180\n     * days.\n     * @param _periods The number of vesting periods. Must be more than 0 and \n     * less then the vesting duration.\n     */\n    function setHatVestingParams(uint32 _duration, uint32 _periods) external;\n\n    /**\n     * @notice Called by governance to set the timelock delay for setting the\n     * max bounty (the time between setPendingMaxBounty and setMaxBounty)\n     * @param _delay The time period for the delay. Must be at least 2 days.\n     */\n    function setMaxBountyDelay(uint32 _delay) external;\n\n    /**\n     * @notice Create a new vault\n     * NOTE: Vaults should not use tokens which do not guarantee that the \n     * amount specified is the amount transferred\n     * @param _params The vault initialization parameters\n     * @return vault The address of the new vault\n     */\n    function createVault(IHATVault.VaultInitParams calldata _params) external returns(address vault);\n\n    /**\n     * @notice Called by governance to change the UI visibility of a vault\n     * @param _vault The address of the vault to update\n     * @param _visible Is this vault visible in the UI\n     * This parameter can be used by the UI to include or exclude the vault\n     */\n    function setVaultVisibility(address _vault, bool _visible) external;\n\n    /**\n     * @notice Transfer the part of the bounty that is supposed to be swapped\n     * into HAT tokens from the HATVault to the registry, and keep track of\n     * the amounts to be swapped and sent/burnt in a later transaction\n     * @param _asset The vault's native token\n     * @param _hacker The address of the beneficiary of the bounty\n     * @param _hackersHatReward The amount of the vault's native token to be\n     * swapped to HAT tokens and sent to the hacker via a vesting contract\n     * @param _governanceHatReward The amount of the vault's native token to\n     * be swapped to HAT tokens and sent to governance\n     */\n    function addTokensToSwap(\n        IERC20 _asset,\n        address _hacker,\n        uint256 _hackersHatReward,\n        uint256 _governanceHatReward\n    ) external;\n\n    /**\n     * @notice Called by governance to swap the given asset to HAT tokens and \n     * distribute the HAT tokens: Send to governance their share and send to\n     * beneficiaries their share through a vesting contract.\n     * @param _asset The address of the token to be swapped to HAT tokens\n     * @param _beneficiaries Addresses of beneficiaries\n     * @param _amountOutMinimum Minimum amount of HAT tokens at swap\n     * @param _routingContract Routing contract to call for the swap\n     * @param _routingPayload Payload to send to the _routingContract for the\n     * swap\n     */\n    function swapAndSend(\n        address _asset,\n        address[] calldata _beneficiaries,\n        uint256 _amountOutMinimum,\n        address _routingContract,\n        bytes calldata _routingPayload\n    ) external;\n  \n    /**\n     * @notice Returns the withdraw enable period for all vaults. The safety\n     * period starts when finished.\n     * @return Withdraw enable period for all vaults\n     */\n    function getWithdrawPeriod() external view returns (uint256);\n\n    /**\n     * @notice Returns the withdraw disable period - time for the committee to\n     * gather and decide on actions, withdrawals are not possible in this\n     * time. The withdraw period starts when finished.\n     * @return Safety period for all vaults\n     */\n    function getSafetyPeriod() external view returns (uint256);\n\n    /**\n     * @notice Returns the withdraw request enable period for all vaults -\n     * period of time after withdrawRequestPendingPeriod where it is possible\n     * to withdraw, and after which withdrawals are not possible.\n     * @return Withdraw request enable period for all vaults\n     */\n    function getWithdrawRequestEnablePeriod() external view returns (uint256);\n\n    /**\n     * @notice Returns the withdraw request pending period for all vaults -\n     * period of time that has to pass after withdraw request until withdraw\n     * is possible\n     * @return Withdraw request pending period for all vaults\n     */\n    function getWithdrawRequestPendingPeriod() external view returns (uint256);\n\n    /**\n     * @notice Returns the set max bounty delay for all vaults - period of\n     * time that has to pass after setting a pending max bounty before it can\n     * be set as the new max bounty\n     * @return Set max bounty delay for all vaults\n     */\n    function getSetMaxBountyDelay() external view returns (uint256);\n\n    /**\n     * @notice Returns the number of vaults that have been previously created\n     * @return The number of vaults in the registry\n     */\n    function getNumberOfVaults() external view returns(uint256);\n\n}\n"
    },
    "contracts/interfaces/IHATVaultsV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\ninterface IHATVaultsV1 {\n\n    struct PoolInfo {\n        address lpToken;\n        uint256 allocPoint;\n        uint256 lastRewardBlock;\n        uint256 rewardPerShare;\n        uint256 totalUsersAmount;\n        uint256 lastProcessedTotalAllocPoint;\n        uint256 balance;\n    }\n\n    struct UserInfo {\n        uint256 amount;\n        uint256 rewardDebt;\n    }\n\n    function poolInfo(uint256 _pid) external view returns (PoolInfo calldata poolInfo);\n\n    function userInfo(uint256 _pid, address _user) external view returns (UserInfo calldata userInfo);\n}\n"
    },
    "contracts/interfaces/IHATVaultsV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IHATVaultsV2 {\n    function hatVaults(uint256 _pid) external view returns (IERC20 hatVault);\n}\n"
    },
    "contracts/interfaces/IRewardController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ninterface IRewardController {\n    \n    error EpochLengthZero();\n    // Not enough rewards to transfer to user\n    error NotEnoughRewardsToTransferToUser();\n\n    event RewardControllerCreated(\n        address _rewardToken,\n        address _governance,\n        uint256 _startBlock,\n        uint256 _epochLength,\n        uint256[24] _epochRewardPerBlock\n    );\n    event SetEpochRewardPerBlock(uint256[24] _epochRewardPerBlock);\n    event SetAllocPoint(address indexed _vault, uint256 _prevAllocPoint, uint256 _allocPoint);\n    event VaultUpdated(address indexed _vault, uint256 _rewardPerShare, uint256 _lastProcessedVaultUpdate);\n    event UserBalanceCommitted(address indexed _vault, address indexed _user, uint256 _unclaimedReward, uint256 _rewardDebt);\n    event ClaimReward(address indexed _vault, address indexed _user, uint256 _amount);\n\n    /**\n     * @notice Initializes the reward controller\n     * @param _rewardToken The address of the ERC20 token to be distributed as rewards\n     * @param _governance The hats governance address, to be given ownership of the reward controller\n     * @param _startRewardingBlock The block number from which to start rewarding\n     * @param _epochLength The length of a rewarding epoch\n     * @param _epochRewardPerBlock The reward per block for each of the 24 epochs\n     */\n    function initialize(\n        address _rewardToken,\n        address _governance,\n        uint256 _startRewardingBlock,\n        uint256 _epochLength,\n        uint256[24] calldata _epochRewardPerBlock\n    ) external;\n\n    /**\n     * @notice Called by the owner to set the allocation points for a vault, meaning the\n     * vault's relative share of the total rewards\n     * @param _vault The address of the vault\n     * @param _allocPoint The allocation points for the vault\n     */\n    function setAllocPoint(address _vault, uint256 _allocPoint) external;\n\n    /**\n    * @notice Update the vault's reward per share, not more then once per block\n    * @param _vault The vault's address\n    */\n    function updateVault(address _vault) external;\n\n    /**\n    * @notice Called by the owner to set reward per epoch\n    * Reward can only be set for epochs which have not yet started\n    * @param _epochRewardPerBlock reward per block for each epoch\n    */\n    function setEpochRewardPerBlock(uint256[24] calldata _epochRewardPerBlock) external;\n\n    /**\n    * @notice Called by the vault to update a user claimable reward after deposit or withdraw.\n    * This call should never revert.\n    * @param _user The user address to updare rewards for\n    * @param _sharesChange The user of shared the user deposited or withdrew\n    * @param _isDeposit Whether user deposited or withdrew\n    */\n    function commitUserBalance(address _user, uint256 _sharesChange, bool _isDeposit) external;\n    /**\n    * @notice Transfer to the specified user their pending share of rewards.\n    * @param _vault The vault address\n    * @param _user The user address to claim for\n    */\n    function claimReward(address _vault, address _user) external;\n\n    /**\n    * @notice Calculate rewards for a vault by iterating over the history of totalAllocPoints updates,\n    * and sum up all rewards periods from vault.lastRewardBlock until current block number.\n    * @param _vault The vault address\n    * @param _fromBlock The block from which to start calculation\n    * @return reward The amount of rewards for the vault\n    */\n    function getVaultReward(address _vault, uint256 _fromBlock) external view returns(uint256 reward);\n\n    /**\n    * @notice Calculate the amount of rewards a user can claim for having contributed to a specific vault\n    * @param _vault The vault address\n    * @param _user The user for which the reward is calculated\n    */\n    function getPendingReward(address _vault, address _user) external view returns (uint256);\n\n    /**\n    * @notice Called by the owner to transfer any tokens held in this contract to the owner\n    * @param _token The token to sweep\n    * @param _amount The amount of token to sweep\n    */\n    function sweepToken(IERC20Upgradeable _token, uint256 _amount) external;\n\n}\n"
    },
    "contracts/mocks/CloneFactoryMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\ncontract CloneFactoryMock {\n    event CloneCreated(address indexed _clone);\n\n    function clone(address target) external returns (address result) {\n        result = Clones.clone(target);\n        emit CloneCreated(result);\n    }\n}\n"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../HATVault.sol\";\n\n\ncontract ERC20Mock is ERC20 {\n\n    /// @notice A record of each accounts delegate\n    mapping (address => address) public delegates;\n\n    bool public approveDisableFlag;\n    bool public approveZeroDisableFlag;\n    bool public badTransferFlag;\n    bool public reenterApproveClaim;\n    bool public reenterDeposit;\n    bool public reenterWithdrawRequest;\n    bool public reenterWithdraw;\n\n    constructor(\n        string memory _name,\n        string memory _symbol\n    )\n    // solhint-disable-next-line func-visibility\n    ERC20(_name, _symbol) {\n        approveDisableFlag = false;\n        approveZeroDisableFlag = false;\n        badTransferFlag = false;\n    }\n\n    function approveDisable(bool _approveDisable) external {\n        approveDisableFlag = _approveDisable;\n    }\n\n    function approveZeroDisable(bool _approveZeroDisable) external {\n        approveZeroDisableFlag = _approveZeroDisable;\n    }\n\n    function setBadTransferFlag(bool _badTransferFlag) external {\n        badTransferFlag = _badTransferFlag;\n    }\n\n    function setReenterApproveClaim(bool _reenterApproveClaim) external {\n        reenterApproveClaim = _reenterApproveClaim;\n    }\n\n    function setReenterDeposit(bool _reenterDeposit) external {\n        reenterDeposit = _reenterDeposit;\n    }\n\n    function setReenterWithdrawRequest(bool _reenterWithdrawRequest) external {\n        reenterWithdrawRequest = _reenterWithdrawRequest;\n    }\n\n    function setReenterWithdraw(bool _reenterWithdraw) external {\n        reenterWithdraw = _reenterWithdraw;\n    }\n\n    function mint(address _to, uint256 _amount) public {\n        _mint(_to, _amount);\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) public {\n        delegates[msg.sender] = delegatee;\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        if (approveDisableFlag || (approveZeroDisableFlag && amount == 0)) {\n            return false;\n        }\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        if (reenterApproveClaim) {\n            HATVault(msg.sender).approveClaim(\"\", 1000);\n        }\n\n        if (reenterDeposit) {\n            HATVault(msg.sender).deposit(1, address(this));\n        }\n\n        if (reenterWithdrawRequest) {\n            HATVault(msg.sender).withdrawRequest();\n        }\n\n        if (reenterWithdraw) {\n            HATVault(msg.sender).withdraw(1, address(this), address(this));\n        }\n\n        if (badTransferFlag) {\n            super._transfer(from, to, amount / 2);\n        } else {\n            super._transfer(from, to, amount);\n        }\n    }\n}\n"
    },
    "contracts/mocks/EtherTransferFail.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n\n\ncontract EtherTransferFail {\n    receive() external payable {\n       revert(\"cannot accept transfer\");\n    }\n   \n}\n"
    },
    "contracts/mocks/HATTokenMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"../HATToken.sol\";\n//solhint-disable func-visibility \n//solhint-disable no-empty-blocks\n\ncontract HATTokenMock is HATToken {\n    constructor(address _governance)\n    HATToken(_governance) {\n    }\n\n    function burnFrom(address _from, uint256 _amount) public {\n        return _burn(_from, _amount);\n    }\n\n    function delegateTwice(address _delegatee, address _delegatee2) public {\n        _delegate(msg.sender, _delegatee);\n        _delegate(msg.sender, _delegatee2);\n        _delegate(msg.sender, _delegatee);\n    }\n\n    function transferFromZero(address _dst, uint256 _amount) public {\n        _transfer(0x0000000000000000000000000000000000000000, _dst, _amount);\n    }\n\n    function getChainId() external view returns (uint256) {\n        return block.chainid;\n    }\n}\n"
    },
    "contracts/mocks/HATVaultsV1Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n\ncontract HATVaultsV1Mock {\n    struct PoolInfo {\n        address lpToken;\n        uint256 allocPoint;\n        uint256 lastRewardBlock;\n        uint256 rewardPerShare;\n        uint256 totalUsersAmount;\n        uint256 lastProcessedTotalAllocPoint;\n        uint256 balance;\n    }\n\n    struct UserInfo {\n        uint256 amount;\n        uint256 rewardDebt;\n    }\n\n    PoolInfo[] public poolInfo;\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n\n    function addShares(uint256 pid, address account, uint256 shares) external {\n        while (pid >= poolInfo.length) {\n            poolInfo.push(PoolInfo({\n                lpToken: address(0),\n                allocPoint: 0,\n                lastRewardBlock: 0,\n                rewardPerShare: 0,\n                totalUsersAmount: 0,\n                lastProcessedTotalAllocPoint: 0,\n                balance: 0\n            }));\n        }\n\n        poolInfo[pid].totalUsersAmount += shares;\n        userInfo[pid][account].amount += shares;\n    }\n}\n"
    },
    "contracts/mocks/HATVaultsV2Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20MockNFT is ERC20 {\n\n    constructor(\n        string memory _name,\n        string memory _symbol\n    )\n    ERC20(_name, _symbol) {}\n\n    function mint(address _to, uint256 _amount) public {\n        _mint(_to, _amount);\n    }\n}\n\ncontract HATVaultsV2Mock {\n    ERC20MockNFT[] public hatVaults;\n\n    function addShares(uint256 pid, address account, uint256 shares) external {\n        while (pid >= hatVaults.length) {\n            hatVaults.push(new ERC20MockNFT(\"HATVault Mock\", \"HVM\"));\n        }\n\n        hatVaults[pid].mint(account, shares);\n    }\n}\n"
    },
    "contracts/mocks/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function WETH9() external pure returns (address);\n}\n"
    },
    "contracts/mocks/PoolsManagerMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"../HATVaultsRegistry.sol\";\nimport \"../RewardController.sol\";\n//this contract is used as an helper contract only for testing purpose\n\ncontract VaultsManagerMock {\n\n    function createVaults(HATVaultsRegistry _hatVaults,\n                    IRewardController _rewardController,\n                    uint256 _allocPoint,\n                    IERC20[] memory _assets,\n                    address _committee,\n                    uint16 _maxBounty,\n                    HATVault.BountySplit memory _bountySplit,\n                    string memory _descriptionHash\n                    ) external {\n\n        IRewardController[] memory _rewardControllers = new IRewardController[](1);\n        _rewardControllers[0] = _rewardController;\n        for (uint256 i=0; i < _assets.length; i++) {\n            address vault = _hatVaults.createVault(IHATVault.VaultInitParams({\n                                    asset: _assets[i],\n                                    owner: _hatVaults.owner(),\n                                    committee: _committee,\n                                    name: \"VAULT\",\n                                    symbol: \"VLT\",\n                                    rewardControllers: _rewardControllers,\n                                    maxBounty: _maxBounty,\n                                    bountySplit: _bountySplit,\n                                    descriptionHash: _descriptionHash,\n                                    vestingDuration: 86400,\n                                    vestingPeriods: 10,\n                                    isPaused: false\n                                }));\n            _rewardController.setAllocPoint(vault, _allocPoint);\n        }\n    }\n\n    function setVaultsAllocPoint(HATVault[] memory _hatVaults, IRewardController _rewardController, uint256 _allocPoint) external {\n        for (uint256 i=0; i < _hatVaults.length; i++) {\n            _rewardController.setAllocPoint(address(_hatVaults[i]), _allocPoint);\n        }\n    }\n\n    function claimRewardTwice(RewardController target, address _vault) external {\n        target.claimReward(_vault, address(this));\n        target.claimReward(_vault, address(this));\n    }\n\n    function deposit(HATVault _target, IERC20 _asset, uint256 _amount) external {\n        _asset.approve(address(_target), _amount);\n        _target.deposit(_amount, address(this));\n    }\n\n    function depositTwice(HATVault _target, IERC20 _asset, uint256 _amount) external {\n        _asset.approve(address(_target), _amount * 2);\n        _target.deposit(_amount, address(this));\n        _target.deposit(_amount, address(this));\n    }\n\n    function claimDifferentPids(RewardController _target, address[] memory _vaults) external {\n        uint256 i;\n        for (i = 0; i < _vaults.length; i++) {\n            _target.claimReward(_vaults[i], address(this));\n        }\n    }\n\n}\n"
    },
    "contracts/mocks/UniSwapV3RouterMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./ISwapRouter.sol\";\n\n\ncontract UniSwapV3RouterMock {\n\n    enum ReturnType {ONE_TO_ONE, MINIMUM, BELOW_MINIMUM}\n\n   /// @notice The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n   /// @notice The length of the bytes encoded fee\n    uint256 private constant FEE_SIZE = 3;\n    /// @notice The offset of a single token address and pool fee\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\n\n    ReturnType public returnType;\n    address public immutable WETH9;\n\n    bool public usePartialAmountFlag;\n\n    constructor(\n        ReturnType _returnType,\n        address _weth9\n    // solhint-disable-next-line func-visibility\n    ) {\n        returnType = _returnType;\n        WETH9 = _weth9;\n    }\n\n    function setUsePartialAmountFlag(bool _usePartialAmountFlag) external {\n        usePartialAmountFlag = _usePartialAmountFlag;\n    }\n\n    function exactInput(\n        ISwapRouter.ExactInputParams memory _params\n    ) external returns (uint256 amount) {\n        uint256 amountToSendBack;\n\n        if (usePartialAmountFlag) {\n            _params.amountIn = _params.amountIn * 80 / 100;\n        }\n\n        if (returnType == ReturnType.ONE_TO_ONE) {\n            amountToSendBack = _params.amountIn;\n        }\n\n        if (returnType == ReturnType.MINIMUM) {\n            amountToSendBack = _params.amountOutMinimum;\n        }\n\n        if (returnType == ReturnType.BELOW_MINIMUM) {\n            amountToSendBack = _params.amountOutMinimum - 1;\n        }\n        address tokennIn = toAddress(_params.path, 0);\n        ERC20(tokennIn).transferFrom(msg.sender, address(this), _params.amountIn);\n        //swap 1 to 1...\n        address tokenOut = toAddress(_params.path, NEXT_OFFSET*numPools(_params.path));\n        IERC20(tokenOut).transfer(_params.recipient, amountToSendBack);\n        return amountToSendBack;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, \"toAddress_overflow\");\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    /// @notice Returns the number of pools in the path\n   /// @param path The encoded swap path\n   /// @return The number of pools in the path\n    function numPools(bytes memory path) internal pure returns (uint256) {\n           // Ignore the first token address. From then on every fee and token offset indicates a pool.\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\n    }\n\n}\n"
    },
    "contracts/nft/HATVaultsNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"../interfaces/IHATVaultsData.sol\";\n\n/*\nAn NFT contract that mints specail tokens for each vault of\nthe HATVaults system.\n@note: Thoroughout the whole contract, the HATVaults address \n       should always be the wrapper contract, not the actual\n       HATVaults contract\n*/\ncontract HATVaultsNFT is ERC1155, Ownable {\n    using Strings for uint256;\n    using Counters for Counters.Counter;\n\n    bytes32 public root;\n    Counters.Counter public totalSupplyCounter;\n    uint256 public deadline;\n\n    uint256 public constant HUNDRED_PERCENT = 10000;\n    uint256 public constant TIERS = 3;\n\n    mapping(bytes32 => bool) public pausedVaults;\n    mapping(bytes32 => bool) public vaultsRegistered;\n    mapping(uint256 => mapping(address => bool)) public tokensRedeemed;\n\n    mapping(uint256 => string) public uris;\n\n    event MerkleTreeChanged(string merkleTreeIPFSRef, bytes32 root, uint256 deadline);\n    event VaultPaused(address indexed hatVaults, uint256 indexed pid);\n    event VaultResumed(address indexed hatVaults, uint256 indexed pid);\n\n    modifier notPaused(address hatVaults, uint256 pid) {\n        require(!pausedVaults[keccak256(abi.encodePacked(hatVaults, pid))], \"Vault paused\");\n        _;\n    }\n\n    constructor(\n        string memory _merkleTreeIPFSRef,\n        bytes32 _root,\n        uint256 _deadline\n    // solhint-disable-next-line func-visibility\n    ) ERC1155(\"\") {\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp < _deadline, \"Deadline already passed\");\n        root = _root;\n        deadline = _deadline;\n        emit MerkleTreeChanged(_merkleTreeIPFSRef, _root, _deadline);\n    }\n\n    function addVault(address hatVaults, uint256 pid, string memory _uri) external onlyOwner {\n        require(!vaultsRegistered[getVaultId(hatVaults, pid)], \"Vault already exists\");\n        vaultsRegistered[getVaultId(hatVaults, pid)] = true;\n        for(uint8 i = 1; i <= TIERS; i++) {\n            uris[getTokenId(hatVaults, pid, i)] = string(abi.encodePacked(_uri, Strings.toString(i)));\n        }\n    }\n\n    function pauseVault(address hatVaults, uint256 pid) external onlyOwner {\n        pausedVaults[keccak256(abi.encodePacked(hatVaults, pid))] = true;\n        emit VaultPaused(hatVaults, pid);\n    }\n\n\n    function resumeVault(address hatVaults, uint256 pid) external onlyOwner {\n        pausedVaults[keccak256(abi.encodePacked(hatVaults, pid))] = false;\n        emit VaultResumed(hatVaults, pid);\n    }\n\n    /**\n     * @dev Update the merkle tree root only after \n     * the deadline for minting has been reached.\n     * @param _merkleTreeIPFSRef new merkle tree ipfs reference.\n     * @param _root new merkle tree root to use for verifying.\n     * @param _deadline number of days to the next minting deadline.\n     */\n    function updateTree(string memory _merkleTreeIPFSRef, bytes32 _root, uint256 _deadline) external onlyOwner {\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp > deadline, \"Minting deadline was not reached\");\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp < _deadline, \"New deadline already passed\");\n        root = _root;\n        deadline = _deadline;\n        emit MerkleTreeChanged(_merkleTreeIPFSRef, _root, _deadline);\n    }\n\n    function redeemMultipleFromTree(\n        address[] calldata hatVaults,\n        uint256[] calldata pids,\n        address account,\n        uint8[] calldata tiers,\n        bytes32[][] calldata proofs\n    ) external {\n        uint256 arraysLength = hatVaults.length;\n        require(arraysLength == pids.length, \"Arrays lengths must match\");\n        require(arraysLength == tiers.length, \"Arrays lengths must match\");\n        require(arraysLength == proofs.length, \"Arrays lengths must match\");\n        for (uint256 i = 0; i < arraysLength; i++) {\n            redeemSingleFromTree(hatVaults[i], pids[i], account, tiers[i], proofs[i]);\n        }\n    }\n\n    function redeemSingleFromTree(\n        address hatVaults,\n        uint256 pid,\n        address account,\n        uint8 tier,\n        bytes32[] calldata proof\n    ) public notPaused(hatVaults, pid) {\n        // solhint-disable-next-line not-rely-on-time\n        require(block.timestamp < deadline, \"Minting deadline passed\");\n        require(_verify(proof, _leaf(hatVaults, pid, account, tier)), \"Invalid merkle proof\");\n        _mintTokens(hatVaults, pid, account, tier);\n    }\n\n    function redeemMultipleFromShares(\n        address[] calldata hatVaults,\n        uint256[] calldata pids,\n        address account\n    ) external {\n        uint256 arraysLength = hatVaults.length;\n        require(arraysLength == pids.length, \"Arrays lengths must match\");\n        for (uint256 i = 0; i < arraysLength; i++) {\n            redeemSingleFromShares(hatVaults[i], pids[i], account);\n        }\n    }\n\n    function redeemSingleFromShares(\n        address hatVaults,\n        uint256 pid,\n        address account\n    ) public {\n        uint8 tier = getTierFromShares(hatVaults, pid, account);\n        if (tier != 0) {\n            _mintTokens(hatVaults, pid, account, tier);\n        } \n    }\n\n    function _mintTokens(\n        address hatVaults,\n        uint256 pid,\n        address account,\n        uint8 tier\n    ) internal {\n        require(vaultsRegistered[getVaultId(hatVaults, pid)], \"Token does not exist\");\n        for(uint8 i = 1; i <= tier; i++) {\n            if (!tokensRedeemed[getTokenId(hatVaults, pid, i)][account]) {\n                tokensRedeemed[getTokenId(hatVaults, pid, i)][account] = true;\n                _mint(account, getTokenId(hatVaults, pid, i));\n            }\n        }\n    }\n\n    function _leaf(address _hatVaults, uint256 _pid, address _account, uint8 _tier) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_hatVaults, _pid, _account, _tier));\n    }\n\n    function _verify(bytes32[] calldata proof, bytes32 leaf) internal view returns (bool) {\n        return MerkleProof.verifyCalldata(proof, root, leaf);\n    }\n\n    function _mint(address to, uint256 id) internal {\n        totalSupplyCounter.increment();\n        super._mint(to, id, 1, \"\");\n    }\n\n    function getTierFromShares(\n        address hatVaults,\n        uint256 pid,\n        address account\n    ) public view notPaused(hatVaults, pid) returns(uint8) {\n        uint256 shares = IHATVaultsData(hatVaults).getShares(pid, account);\n        uint256 totalShares = IHATVaultsData(hatVaults).getTotalShares(pid);\n        require(totalShares != 0, \"Pool is empty\");\n        uint16[3] memory tierPercents = [10, 100, 1500];\n        uint8 tier = 0;\n\n        for(uint8 i = 0; i < tierPercents.length; i++) {\n            if (shares < totalShares * tierPercents[i] / HUNDRED_PERCENT) {\n                break;\n            }\n            tier++;\n        }\n\n        return tier;\n    }\n\n    function getTiersToRedeemFromShares(\n        address hatVaults,\n        uint256 pid,\n        address account\n    ) external view returns(bool[3] memory tiers) {\n        require(vaultsRegistered[getVaultId(hatVaults, pid)], \"Token does not exist\");\n        for(uint8 i = 1; i <= getTierFromShares(hatVaults, pid, account); i++) {\n            if (!tokensRedeemed[getTokenId(hatVaults, pid, i)][account]) {\n                tiers[i - 1] = true;\n            }\n        }\n    }\n\n    function isEligible(\n        address hatVaults,\n        uint256 pid,\n        address account\n    ) external view returns(bool) {\n        uint8 tier = getTierFromShares(hatVaults, pid, account);\n        return tier != 0 && (vaultsRegistered[getVaultId(hatVaults, pid)] && !tokensRedeemed[getTokenId(hatVaults, pid, tier)][account]);\n    }\n\n    function getTokenId(\n        address hatVaults,\n        uint256 pid,\n        uint8 tier\n    ) public pure returns(uint256) {\n        return uint256(keccak256(abi.encodePacked(hatVaults, pid, tier)));\n    }\n\n    function getVaultId(\n        address hatVaults,\n        uint256 pid\n    ) public pure returns(bytes32) {\n        return keccak256(abi.encodePacked(hatVaults, pid));\n    }\n\n    /**\n        @dev Returns thze total tokens minted so far.\n     */\n    function totalSupply() public view returns (uint256) {\n        return totalSupplyCounter.current();\n    }\n\n    function uri(uint256 tokenId) public view override returns (string memory) {\n        return uris[tokenId];\n    }\n}\n"
    },
    "contracts/nft/HATVaultsV1Data.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"../interfaces/IHATVaultsV1.sol\";\nimport \"../interfaces/IHATVaultsData.sol\";\n\ncontract HATVaultsV1Data is IHATVaultsData {\n    IHATVaultsV1 public hatVaults;\n\n    constructor(IHATVaultsV1 _hatVaults) {\n        hatVaults = _hatVaults;\n    }\n\n    function getTotalShares(uint256 _pid) external view returns (uint256) {\n        return hatVaults.poolInfo(_pid).totalUsersAmount;\n    }\n\n    function getShares(uint256 _pid, address _user) external view returns (uint256) {\n        return hatVaults.userInfo(_pid, _user).amount;\n    }\n}\n"
    },
    "contracts/nft/HATVaultsV2Data.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"../interfaces/IHATVaultsV2.sol\";\nimport \"../interfaces/IHATVaultsData.sol\";\n\ncontract HATVaultsV2Data is IHATVaultsData {\n    IHATVaultsV2 public hatVaults;\n\n    constructor(IHATVaultsV2 _hatVaults) {\n        hatVaults = _hatVaults;\n    }\n\n    function getTotalShares(uint256 _pid) external view returns (uint256) {\n        return hatVaults.hatVaults(_pid).totalSupply();\n    }\n\n    function getShares(uint256 _pid, address _user) external view returns (uint256) {\n        return hatVaults.hatVaults(_pid).balanceOf(_user);\n    }\n}\n"
    },
    "contracts/RewardController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Disclaimer https://github.com/hats-finance/hats-contracts/blob/main/DISCLAIMER.md\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IRewardController.sol\";\n\n\ncontract RewardController is IRewardController, OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using Math for uint256;\n\n    struct VaultInfo {\n        uint256 rewardPerShare;\n        uint256 lastProcessedVaultUpdate;\n        uint256 lastRewardBlock;\n        uint256 allocPoint;\n    }\n\n    struct VaultUpdate {\n        uint256 blockNumber;// update blocknumber\n        uint256 totalAllocPoint; //totalAllocPoint\n    }\n\n    uint256 public constant REWARD_PRECISION = 1e12;\n    uint256 public constant NUMBER_OF_EPOCHS = 24;\n\n    // Block from which the contract will start rewarding.\n    uint256 public startBlock;\n    uint256 public epochLength;\n    // the ERC20 contract in which rewards are distributed\n    IERC20Upgradeable public rewardToken;\n    // amount of tokens rewarded in each block, per epoch\n    uint256[24] public epochRewardPerBlock;\n    VaultUpdate[] public globalVaultsUpdates;\n    mapping(address => VaultInfo) public vaultInfo;\n    // vault address => user address => reward debt amount\n    mapping(address => mapping(address => uint256)) public rewardDebt;\n    // vault address => user address => unclaimed reward amount\n    mapping(address => mapping(address => uint256)) public unclaimedReward;\n\n    /** @notice See {IRewardController-initialize}. */\n    function initialize(\n        address _rewardToken,\n        address _governance,\n        uint256 _startRewardingBlock,\n        uint256 _epochLength,\n        uint256[24] calldata _epochRewardPerBlock\n    ) external initializer {\n        if (_epochLength == 0) revert EpochLengthZero();\n        rewardToken = IERC20Upgradeable(_rewardToken);\n        startBlock = _startRewardingBlock;\n        epochLength = _epochLength;\n        epochRewardPerBlock = _epochRewardPerBlock;\n        _transferOwnership(_governance);\n        emit RewardControllerCreated(_rewardToken, _governance, _startRewardingBlock, _epochLength, _epochRewardPerBlock);\n    }\n\n    /** @notice See {IRewardController-setAllocPoint}. */\n    function setAllocPoint(address _vault, uint256 _allocPoint) external onlyOwner {        \n        updateVault(_vault);\n        uint256 _totalAllocPoint;\n        uint256 _globalVaultsUpdatesLength = globalVaultsUpdates.length;\n        bool _isAllocated;\n\n         if (_globalVaultsUpdatesLength != 0) {\n            uint256 _globalVaultsUpdatesLastIndex;\n            unchecked { // only used in case _globalVaultsUpdatesLength > 0\n                _globalVaultsUpdatesLastIndex = _globalVaultsUpdatesLength - 1;\n            }\n            VaultUpdate storage vaultUpdate = globalVaultsUpdates[_globalVaultsUpdatesLastIndex];\n            _totalAllocPoint = vaultUpdate.totalAllocPoint - vaultInfo[_vault].allocPoint + _allocPoint;\n            if (vaultUpdate.blockNumber == block.number) {\n                // already update in this block\n                vaultUpdate.totalAllocPoint = _totalAllocPoint;\n                _isAllocated = true;\n            }\n        } else {\n            _totalAllocPoint = _allocPoint;\n        }\n\n        if (!_isAllocated) {\n            globalVaultsUpdates.push(VaultUpdate({\n                blockNumber: block.number,\n                totalAllocPoint: _totalAllocPoint\n            }));\n        }\n\n        emit SetAllocPoint(_vault, vaultInfo[_vault].allocPoint, _allocPoint);\n        vaultInfo[_vault].allocPoint = _allocPoint;\n    }\n\n    /** @notice See {IRewardController-updateVault}. */\n    function updateVault(address _vault) public {\n        VaultInfo storage vault = vaultInfo[_vault];\n        uint256 _lastRewardBlock = vault.lastRewardBlock;\n        if (_lastRewardBlock == 0) {\n            uint256 _startBlock = startBlock;\n            vault.lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;\n            return;\n        }\n        if (block.number == _lastRewardBlock) {\n            return;\n        }\n\n        vault.lastRewardBlock = block.number;\n\n        uint256 _totalShares = IERC20Upgradeable(_vault).totalSupply();\n\n        if (_totalShares != 0) {\n            uint256 _reward = getVaultReward(_vault, _lastRewardBlock);\n            vault.rewardPerShare += _reward.mulDiv(REWARD_PRECISION, _totalShares);\n        }\n\n        uint256 _globalVaultsUpdatesLength = globalVaultsUpdates.length;\n        if (_globalVaultsUpdatesLength != 0) {\n            vault.lastProcessedVaultUpdate = _globalVaultsUpdatesLength - 1;\n        }\n\n        emit VaultUpdated(_vault, vault.rewardPerShare, vault.lastProcessedVaultUpdate);\n    }\n\n    /** @notice See {IRewardController-setEpochRewardPerBlock}. */\n    function setEpochRewardPerBlock(uint256[24] calldata _epochRewardPerBlock) external onlyOwner {\n        // if rewards have not started yet, update the full list\n        uint256 _startBlock = startBlock;\n        if (block.number < _startBlock) {\n            epochRewardPerBlock = _epochRewardPerBlock;\n            emit SetEpochRewardPerBlock(_epochRewardPerBlock);\n        } else {\n            uint256 _nextEpoch = (block.number - _startBlock) / epochLength + 1;\n            // if rewards are ongoing, update the future rewards but keep past and current\n            for (; _nextEpoch < NUMBER_OF_EPOCHS; ++_nextEpoch) {\n                epochRewardPerBlock[_nextEpoch] = _epochRewardPerBlock[_nextEpoch];\n            }\n            emit SetEpochRewardPerBlock(epochRewardPerBlock);\n        }\n    }\n\n    function _commitUserBalance(\n        address _vault,\n        address _user,\n        uint256 _sharesChange,\n        bool _isDeposit\n    ) internal {\n        updateVault(_vault);\n\n        uint256 _userShares = IERC20Upgradeable(_vault).balanceOf(_user);\n        uint256 _rewardPerShare = vaultInfo[_vault].rewardPerShare;\n        mapping(address => uint256) storage vaultRewardDebt = rewardDebt[_vault];\n        if (_userShares != 0) {\n            unclaimedReward[_vault][_user] += _userShares.mulDiv(_rewardPerShare, REWARD_PRECISION) - vaultRewardDebt[_user];\n        }\n\n        if (_sharesChange != 0) {\n            if (_isDeposit) {\n                _userShares += _sharesChange;\n            } else {\n                _userShares -= _sharesChange;\n            }\n        }\n        uint256 _newRewardDebt = _userShares.mulDiv(_rewardPerShare, REWARD_PRECISION);\n        vaultRewardDebt[_user] = _newRewardDebt;\n        emit UserBalanceCommitted(_vault, _user, unclaimedReward[_vault][_user], _newRewardDebt);\n    }\n\n    /** @notice See {IRewardController-commitUserBalance}. */\n    function commitUserBalance(address _user, uint256 _sharesChange, bool _isDeposit) external {\n        _commitUserBalance(msg.sender, _user, _sharesChange, _isDeposit);\n    }\n\n    /** @notice See {IRewardController-claimReward}. */\n    function claimReward(address _vault, address _user) external {\n        _commitUserBalance(_vault, _user, 0, true);\n        mapping(address => uint256) storage vaultUnclaimedReward = unclaimedReward[_vault];\n        uint256 _userUnclaimedReward = vaultUnclaimedReward[_user];\n        if (_userUnclaimedReward > 0) {\n            vaultUnclaimedReward[_user] = 0;\n            rewardToken.safeTransfer(_user, _userUnclaimedReward);\n        }\n\n        emit ClaimReward(_vault, _user, _userUnclaimedReward);\n    }\n\n    /** @notice See {IRewardController-getVaultReward}. */\n    function getVaultReward(address _vault, uint256 _fromBlock) public view returns(uint256 reward) {\n        uint256 _globalVaultsUpdatesLength = globalVaultsUpdates.length ;\n        if (_globalVaultsUpdatesLength == 0) {\n            return 0;\n        }\n        VaultInfo memory _vaultInfo = vaultInfo[_vault];\n        uint256 _vaultAllocPoint = _vaultInfo.allocPoint;\n        uint256 i = _vaultInfo.lastProcessedVaultUpdate;\n        uint256 _globalVaultsUpdatesLastIndex;\n        unchecked { // reach here only if _globalVaultsUpdatesLength > 0\n            _globalVaultsUpdatesLastIndex = _globalVaultsUpdatesLength - 1;\n        }    \n        for (; i < _globalVaultsUpdatesLastIndex;) { \n            uint256 nextUpdateBlock = globalVaultsUpdates[i+1].blockNumber;\n            reward += getRewardForBlocksRange(_fromBlock,\n                                            nextUpdateBlock,\n                                            _vaultAllocPoint,\n                                            globalVaultsUpdates[i].totalAllocPoint);\n            _fromBlock = nextUpdateBlock;\n            unchecked { ++i; }\n        }\n        return reward + getRewardForBlocksRange(_fromBlock,\n                                                block.number,\n                                                _vaultAllocPoint,\n                                                globalVaultsUpdates[i].totalAllocPoint);\n    }\n\n    function getRewardForBlocksRange(uint256 _fromBlock, uint256 _toBlock, uint256 _allocPoint, uint256 _totalAllocPoint)\n    public\n    view\n    returns (uint256 reward) {\n        uint256 _startBlock = startBlock;\n        if ((_fromBlock >= _startBlock && _toBlock >= _fromBlock) && _totalAllocPoint > 0) {\n            uint256 _result;\n            uint256 _epochLength = epochLength;\n            uint256 _epochReward;\n            uint256 _endBlock;\n            uint256 i = (_fromBlock - _startBlock) / _epochLength + 1;\n            for (; i <= NUMBER_OF_EPOCHS;) {\n                _endBlock = _epochLength * i + _startBlock;\n                if (_toBlock <= _endBlock) {\n                    break;\n                }\n                unchecked { // i >= 1\n                    _epochReward = epochRewardPerBlock[i-1];\n                }\n                _result += (_endBlock - _fromBlock) * _epochReward;\n                _fromBlock = _endBlock;\n                unchecked { ++i; }\n            }\n            uint256 _blockDifference;\n            unchecked { // i >= 1, _toBlock >= _fromBlock\n                _epochReward = i > NUMBER_OF_EPOCHS ? 0 : epochRewardPerBlock[i-1];\n                _blockDifference = _toBlock - _fromBlock;\n            }\n            _result += _blockDifference * _epochReward;\n            reward = _result.mulDiv(_allocPoint, _totalAllocPoint);\n        }\n    }\n\n    /** @notice See {IRewardController-getPendingReward}. */\n    function getPendingReward(address _vault, address _user) external view returns (uint256) {\n        mapping(address => uint256) storage vaultUnclaimedReward = unclaimedReward[_vault];\n\n        VaultInfo memory _vaultInfo = vaultInfo[_vault];\n        uint256 _rewardPerShare = _vaultInfo.rewardPerShare;\n        uint256 _totalShares = IERC20Upgradeable(_vault).totalSupply();\n\n        if (_totalShares > 0 && _vaultInfo.lastRewardBlock != 0 && block.number > _vaultInfo.lastRewardBlock) {\n            uint256 reward = getVaultReward(_vault, _vaultInfo.lastRewardBlock);\n            _rewardPerShare += reward.mulDiv(REWARD_PRECISION, _totalShares);\n        }\n\n        return IERC20Upgradeable(_vault).balanceOf(_user).mulDiv(_rewardPerShare, REWARD_PRECISION) + \n                vaultUnclaimedReward[_user] - rewardDebt[_vault][_user];\n    }\n\n    /** @notice See {IRewardController-sweepToken}. */\n    function sweepToken(IERC20Upgradeable _token, uint256 _amount) external onlyOwner {\n        _token.safeTransfer(msg.sender, _amount);\n    }\n\n    function getGlobalVaultsUpdatesLength() external view returns (uint256) {\n        return globalVaultsUpdates.length;\n    }\n\n}\n"
    },
    "contracts/tokenlock/HATTokenLock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"./TokenLock.sol\";\nimport \"../HATToken.sol\";\n\n\ncontract HATTokenLock is TokenLock {\n\n    bool public canDelegate;\n\n    // Initializer\n    function initialize(\n        address _tokenLockOwner,\n        address _beneficiary,\n        HATToken _token,\n        uint256 _managedAmount,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _periods,\n        uint256 _releaseStartTime,\n        uint256 _vestingCliffTime,\n        Revocability _revocable,\n        bool _canDelegate\n    ) external {\n        _initialize(\n            _tokenLockOwner,\n            _beneficiary,\n            address(_token),\n            _managedAmount,\n            _startTime,\n            _endTime,\n            _periods,\n            _releaseStartTime,\n            _vestingCliffTime,\n            _revocable\n        );\n        if (_canDelegate) {\n            _token.delegate(_beneficiary);\n            canDelegate = true;\n        }      \n    }\n\n    /// @dev delegate voting power\n    /// @param _delegatee Address of delegatee\n    function delegate(address _delegatee)\n        external\n        onlyBeneficiary\n    {\n        require(canDelegate, \"delegate is disable\");\n        HATToken(address(token)).delegate(_delegatee);\n    }\n}\n"
    },
    "contracts/tokenlock/ITokenLock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\npragma experimental ABIEncoderV2;\n\ninterface ITokenLock {\n    enum Revocability { NotSet, Enabled, Disabled }\n\n    // -- Value Transfer --\n\n    function release() external;\n\n    function withdrawSurplus(uint256 _amount) external;\n\n    function revoke() external;\n\n    // -- Balances --\n\n    function currentBalance() external view returns (uint256);\n\n    // -- Time & Periods --\n\n    function currentTime() external view returns (uint256);\n\n    function duration() external view returns (uint256);\n\n    function sinceStartTime() external view returns (uint256);\n\n    function amountPerPeriod() external view returns (uint256);\n\n    function periodDuration() external view returns (uint256);\n\n    function currentPeriod() external view returns (uint256);\n\n    function passedPeriods() external view returns (uint256);\n\n    // -- Locking & Release Schedule --\n\n    function availableAmount() external view returns (uint256);\n\n    function vestedAmount() external view returns (uint256);\n\n    function releasableAmount() external view returns (uint256);\n\n    function totalOutstandingAmount() external view returns (uint256);\n\n    function surplusAmount() external view returns (uint256);\n}\n"
    },
    "contracts/tokenlock/ITokenLockFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"./ITokenLock.sol\";\n\ninterface ITokenLockFactory {\n    // -- Factory --\n    function setMasterCopy(address _masterCopy) external;\n\n    function createTokenLock(\n        address _token,\n        address _owner,\n        address _beneficiary,\n        uint256 _managedAmount,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _periods,\n        uint256 _releaseStartTime,\n        uint256 _vestingCliffTime,\n        ITokenLock.Revocability _revocable,\n        bool _canDelegate\n    ) external returns(address contractAddress);\n}\n"
    },
    "contracts/tokenlock/TokenLock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./ITokenLock.sol\";\n\n// this contract is based on GraphTokenLock\n// see https://github.com/graphprotocol/token-distribution/blob/main/contracts/GraphTokenLock.sol\n\n/**\n * @title TokenLock\n * @notice Contract that manages an unlocking schedule of tokens.\n * The contract lock holds a certain amount of tokens deposited  and insures that\n * they can only be released under certain time conditions.\n *\n * This contract implements a release scheduled based on periods and tokens are released in steps\n * after each period ends. It can be configured with one period in which case it is like a plain TimeLock.\n * The contract also supports revocation to be used for vesting schedules. In case that the contract is configured to be  revocable,\n * the owner can revoke the contract at any time and the unvested tokens will be sent back to the owner, even if the \n * the beneficiary has accepted the lock.\n *\n * The contract supports receiving extra funds than the managed tokens ones that can be\n * withdrawn by the beneficiary at any time.\n *\n * A releaseStartTime parameter is included to override the default release schedule and\n * perform the first release on the configured time. After that it will continue with the\n * default schedule.\n */\n// solhint-disable-next-line indent\nabstract contract TokenLock is Ownable, ITokenLock {\n    using SafeERC20 for IERC20;\n\n    uint256 private constant MIN_PERIOD = 1;\n\n    // -- State --\n\n    IERC20 public token;\n    address public beneficiary;\n\n    // Configuration\n\n    // Amount of tokens managed by the contract schedule\n    uint256 public managedAmount;\n\n    uint256 public startTime; // Start datetime (in unixtimestamp)\n    uint256 public endTime; // Datetime after all funds are fully vested/unlocked (in unixtimestamp)\n    uint256 public periods; // Number of vesting/release periods\n\n    // First release date for tokens (in unixtimestamp)\n    // If set, no tokens will be released before releaseStartTime ignoring\n    // the amount to release each period\n    uint256 public releaseStartTime;\n    // A cliff set a date to which a beneficiary needs to get to vest\n    // all preceding periods\n    uint256 public vestingCliffTime;\n    Revocability public revocable; // Whether to use vesting for locked funds\n\n    // State\n\n    bool public isRevoked;\n    bool public isInitialized;\n    bool public isAccepted;\n    uint256 public releasedAmount;\n\n    // -- Events --\n\n    event TokensReleased(address indexed beneficiary, uint256 amount);\n    event TokensWithdrawn(address indexed beneficiary, uint256 amount);\n    event TokensRevoked(address indexed beneficiary, uint256 amount);\n    event BeneficiaryChanged(address newBeneficiary);\n    event LockAccepted();\n    event LockCanceled();\n\n    /**\n     * @dev Only allow calls from the beneficiary of the contract\n     */\n    modifier onlyBeneficiary() {\n        require(msg.sender == beneficiary, \"!auth\");\n        _;\n    }\n\n    constructor() {\n        endTime = type(uint256).max;\n        isInitialized = true;\n    }\n\n    /**\n     * @notice Change the beneficiary of funds managed by the contract\n     * @dev Can only be called by the beneficiary\n     * @param _newBeneficiary Address of the new beneficiary address\n     */\n    function changeBeneficiary(address _newBeneficiary) external onlyBeneficiary {\n        require(_newBeneficiary != address(0), \"Empty beneficiary\");\n        beneficiary = _newBeneficiary;\n        emit BeneficiaryChanged(_newBeneficiary);\n    }\n\n    /**\n     * @notice Beneficiary accepts the lock, the owner cannot cancel the lock. But in case that the contract is defined as revocable,\n     * the owner can revoke the contract at any time and retrieve all unvested tokens.\n     * @dev Can only be called by the beneficiary\n     */\n    function acceptLock() external onlyBeneficiary {\n        isAccepted = true;\n        emit LockAccepted();\n    }\n\n    /**\n     * @notice Owner cancel the lock and return the balance in the contract\n     * @dev Can only be called by the owner\n     */\n    function cancelLock() external onlyOwner {\n        require(isAccepted == false, \"Cannot cancel accepted contract\");\n\n        token.safeTransfer(owner(), currentBalance());\n\n        emit LockCanceled();\n    }\n\n    // -- Value Transfer --\n\n    /**\n     * @notice Releases tokens based on the configured schedule\n     * @dev All available releasable tokens are transferred to beneficiary\n     */\n    function release() external override onlyBeneficiary {\n        uint256 amountToRelease = releasableAmount();\n        require(amountToRelease > 0, \"No available releasable amount\");\n\n        releasedAmount += amountToRelease;\n\n        token.safeTransfer(beneficiary, amountToRelease);\n\n        emit TokensReleased(beneficiary, amountToRelease);\n\n        trySelfDestruct();\n    }\n\n    /**\n     * @notice Withdraws surplus, unmanaged tokens from the contract\n     * @dev Tokens in the contract over outstanding amount are considered as surplus\n     * @param _amount Amount of tokens to withdraw\n     */\n    function withdrawSurplus(uint256 _amount) external override onlyBeneficiary {\n        require(_amount > 0, \"Amount cannot be zero\");\n        require(surplusAmount() >= _amount, \"Amount requested > surplus available\");\n\n        token.safeTransfer(beneficiary, _amount);\n\n        emit TokensWithdrawn(beneficiary, _amount);\n\n        trySelfDestruct();\n    }\n\n    /**\n     * @notice Revokes a vesting schedule and return the unvested tokens to the owner\n     * @dev Vesting schedule is always calculated based on managed tokens\n     */\n    function revoke() external override onlyOwner {\n        require(revocable == Revocability.Enabled, \"Contract is non-revocable\");\n        require(isRevoked == false, \"Already revoked\");\n\n        uint256 unvestedAmount = managedAmount - vestedAmount();\n        require(unvestedAmount > 0, \"No available unvested amount\");\n\n        isRevoked = true;\n\n        token.safeTransfer(owner(), unvestedAmount);\n\n        emit TokensRevoked(beneficiary, unvestedAmount);\n    }\n\n    /// @dev sweeps out accidentally sent tokens\n    /// @param _token Address of token to sweep\n    function sweepToken(IERC20 _token) external {\n        address sweeper = owner() == address(0) ? beneficiary : owner();\n        require(msg.sender == sweeper, \"!auth\");\n        require(_token != token, \"cannot sweep vested token\");\n        uint256 tokenBalance = _token.balanceOf(address(this));\n        if (tokenBalance > 0) {\n            _token.safeTransfer(sweeper, tokenBalance);\n        }\n    }\n\n    // -- Balances --\n\n    /**\n     * @notice Returns the amount of tokens currently held by the contract\n     * @return Tokens held in the contract\n     */\n    function currentBalance() public override view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    // -- Time & Periods --\n\n    /**\n     * @notice Returns the current block timestamp\n     * @return Current block timestamp\n     */\n    function currentTime() public override view returns (uint256) {\n        // solhint-disable-next-line not-rely-on-time\n        return block.timestamp;\n    }\n\n    /**\n     * @notice Gets duration of contract from start to end in seconds\n     * @return Amount of seconds from contract startTime to endTime\n     */\n    function duration() public override view returns (uint256) {\n        return endTime - startTime;\n    }\n\n    /**\n     * @notice Gets time elapsed since the start of the contract\n     * @dev Returns zero if called before conctract starTime\n     * @return Seconds elapsed from contract startTime\n     */\n    function sinceStartTime() public override view returns (uint256) {\n        uint256 current = currentTime();\n        if (current <= startTime) {\n            return 0;\n        }\n        return current - startTime;\n    }\n\n    /**\n     * @notice Returns amount available to be released after each period according to schedule\n     * @return Amount of tokens available after each period\n     */\n    function amountPerPeriod() public override view returns (uint256) {\n        return managedAmount / periods;\n    }\n\n    /**\n     * @notice Returns the duration of each period in seconds\n     * @return Duration of each period in seconds\n     */\n    function periodDuration() public override view returns (uint256) {\n        return duration() / periods;\n    }\n\n    /**\n     * @notice Gets the current period based on the schedule\n     * @return A number that represents the current period\n     */\n    function currentPeriod() public override view returns (uint256) {\n        return sinceStartTime() / periodDuration() + MIN_PERIOD;\n    }\n\n    /**\n     * @notice Gets the number of periods that passed since the first period\n     * @return A number of periods that passed since the schedule started\n     */\n    function passedPeriods() public override view returns (uint256) {\n        return currentPeriod() - MIN_PERIOD;\n    }\n\n    // -- Locking & Release Schedule --\n\n    /**\n     * @notice Gets the currently available token according to the schedule\n     * @dev Implements the step-by-step schedule based on periods for available tokens\n     * @return Amount of tokens available according to the schedule\n     */\n    function availableAmount() public override view returns (uint256) {\n        uint256 current = currentTime();\n\n        // Before contract start no funds are available\n        if (current < startTime) {\n            return 0;\n        }\n\n        // After contract ended all funds are available\n        if (current > endTime) {\n            return managedAmount;\n        }\n\n        // Get available amount based on period\n        return passedPeriods() * amountPerPeriod();\n    }\n\n    /**\n     * @notice Gets the amount of currently vested tokens\n     * @dev Similar to available amount, but is fully vested when contract is non-revocable\n     * @return Amount of tokens already vested\n     */\n    function vestedAmount() public override view returns (uint256) {\n        // If non-revocable it is fully vested\n        if (revocable == Revocability.Disabled) {\n            return managedAmount;\n        }\n\n        // Vesting cliff is activated and it has not passed means nothing is vested yet\n        if (vestingCliffTime > 0 && currentTime() < vestingCliffTime) {\n            return 0;\n        }\n\n        return availableAmount();\n    }\n\n    /**\n     * @notice Gets tokens currently available for release\n     * @dev Considers the schedule and takes into account already released tokens\n     * @return Amount of tokens ready to be released\n     */\n    function releasableAmount() public override view returns (uint256) {\n        // If a release start time is set no tokens are available for release before this date\n        // If not set it follows the default schedule and tokens are available on\n        // the first period passed\n        if (releaseStartTime > 0 && currentTime() < releaseStartTime) {\n            return 0;\n        }\n\n        // Vesting cliff is activated and it has not passed means nothing is vested yet\n        // so funds cannot be released\n        if (revocable == Revocability.Enabled && vestingCliffTime > 0 && currentTime() < vestingCliffTime) {\n            return 0;\n        }\n\n        // A beneficiary can never have more releasable tokens than the contract balance\n        uint256 releasable = availableAmount() - releasedAmount;\n        return Math.min(currentBalance(), releasable);\n    }\n\n    /**\n     * @notice Gets the outstanding amount yet to be released based on the whole contract lifetime\n     * @dev Does not consider schedule but just global amounts tracked\n     * @return Amount of outstanding tokens for the lifetime of the contract\n     */\n    function totalOutstandingAmount() public override view returns (uint256) {\n        return managedAmount - releasedAmount;\n    }\n\n    /**\n     * @notice Gets surplus amount in the contract based on outstanding amount to release\n     * @dev All funds over outstanding amount is considered surplus that can be withdrawn by beneficiary\n     * @return Amount of tokens considered as surplus\n     */\n    function surplusAmount() public override view returns (uint256) {\n        uint256 balance = currentBalance();\n        uint256 outstandingAmount = totalOutstandingAmount();\n        if (balance > outstandingAmount) {\n            return balance - outstandingAmount;\n        }\n        return 0;\n    }\n\n    /**\n     * @notice Initializes the contract\n     * @param _tokenLockOwner Address of the contract owner\n     * @param _beneficiary Address of the beneficiary of locked tokens\n     * @param _managedAmount Amount of tokens to be managed by the lock contract\n     * @param _startTime Start time of the release schedule\n     * @param _endTime End time of the release schedule\n     * @param _periods Number of periods between start time and end time\n     * @param _releaseStartTime Override time for when the releases start\n     * @param _vestingCliffTime Override time for when the vesting start\n     * @param _revocable Whether the contract is revocable\n     */\n    function _initialize(\n        address _tokenLockOwner,\n        address _beneficiary,\n        address _token,\n        uint256 _managedAmount,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _periods,\n        uint256 _releaseStartTime,\n        uint256 _vestingCliffTime,\n        Revocability _revocable\n    ) internal {\n        require(!isInitialized, \"Already initialized\");\n        require(_beneficiary != address(0), \"Beneficiary cannot be zero\");\n        require(_token != address(0), \"Token cannot be zero\");\n        require(_managedAmount > 0, \"Managed tokens cannot be zero\");\n        require(_startTime != 0, \"Start time must be set\");\n        require(_startTime < _endTime, \"Start time > end time\");\n        require(_periods >= MIN_PERIOD, \"Periods cannot be below minimum\");\n        require(_revocable != Revocability.NotSet, \"Must set a revocability option\");\n        require(_releaseStartTime < _endTime, \"Release start time must be before end time\");\n        require(_vestingCliffTime < _endTime, \"Cliff time must be before end time\");\n\n        isInitialized = true;\n\n        _transferOwnership(_tokenLockOwner);\n        beneficiary = _beneficiary;\n        token = IERC20(_token);\n\n        managedAmount = _managedAmount;\n\n        startTime = _startTime;\n        endTime = _endTime;\n        periods = _periods;\n\n        // Optionals\n        releaseStartTime = _releaseStartTime;\n        vestingCliffTime = _vestingCliffTime;\n        revocable = _revocable;\n    }\n\n    function trySelfDestruct() private {\n        if (currentTime() > endTime && currentBalance() == 0) {\n            selfdestruct(payable(msg.sender));\n        }\n    }\n}\n"
    },
    "contracts/tokenlock/TokenLockFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"./ITokenLockFactory.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n\n/**\n * @title TokenLockFactory\n *  a factory of TokenLock contracts.\n *\n * This contract receives funds to make the process of creating TokenLock contracts\n * easier by distributing them the initial tokens to be managed.\n */\ncontract TokenLockFactory is ITokenLockFactory, Ownable {\n    // -- State --\n\n    address public masterCopy;\n\n    // -- Events --\n\n    event MasterCopyUpdated(address indexed masterCopy);\n\n    event TokenLockCreated(\n        address indexed contractAddress,\n        bytes32 indexed initHash,\n        address indexed beneficiary,\n        address token,\n        uint256 managedAmount,\n        uint256 startTime,\n        uint256 endTime,\n        uint256 periods,\n        uint256 releaseStartTime,\n        uint256 vestingCliffTime,\n        ITokenLock.Revocability revocable,\n        bool canDelegate\n    );\n\n    /**\n     * Constructor.\n     * @param _masterCopy Address of the master copy to use to clone proxies\n     * @param _governance Owner of the factory\n     */\n    constructor(address _masterCopy, address _governance) {\n        setMasterCopy(_masterCopy);\n        _transferOwnership(_governance);\n    }\n\n    // -- Factory --\n    /**\n     * @notice Creates and fund a new token lock wallet using a minimum proxy\n     * @param _token token to time lock\n     * @param _owner Address of the contract owner\n     * @param _beneficiary Address of the beneficiary of locked tokens\n     * @param _managedAmount Amount of tokens to be managed by the lock contract\n     * @param _startTime Start time of the release schedule\n     * @param _endTime End time of the release schedule\n     * @param _periods Number of periods between start time and end time\n     * @param _releaseStartTime Override time for when the releases start\n     * @param _revocable Whether the contract is revocable\n     * @param _canDelegate Whether the contract should call delegate\n     */\n    function createTokenLock(\n        address _token,\n        address _owner,\n        address _beneficiary,\n        uint256 _managedAmount,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _periods,\n        uint256 _releaseStartTime,\n        uint256 _vestingCliffTime,\n        ITokenLock.Revocability _revocable,\n        bool _canDelegate\n    ) external override returns(address contractAddress) {\n        // Create contract using a minimal proxy and call initializer\n        bytes memory initializer = abi.encodeWithSignature(\n            \"initialize(address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,uint8,bool)\",\n            _owner,\n            _beneficiary,\n            _token,\n            _managedAmount,\n            _startTime,\n            _endTime,\n            _periods,\n            _releaseStartTime,\n            _vestingCliffTime,\n            _revocable,\n            _canDelegate\n        );\n\n        contractAddress = deployProxyPrivate(initializer,\n        _beneficiary,\n        _token,\n        _managedAmount,\n        _startTime,\n        _endTime,\n        _periods,\n        _releaseStartTime,\n        _vestingCliffTime,\n        _revocable,\n        _canDelegate);\n    }\n\n    /**\n     * @notice Sets the masterCopy bytecode to use to create clones of TokenLock contracts\n     * @param _masterCopy Address of contract bytecode to factory clone\n     */\n    function setMasterCopy(address _masterCopy) public override onlyOwner {\n        require(_masterCopy != address(0), \"MasterCopy cannot be zero\");\n        masterCopy = _masterCopy;\n        emit MasterCopyUpdated(_masterCopy);\n    }\n\n    //this private function is to handle stack too deep issue\n    function  deployProxyPrivate(\n        bytes memory _initializer,\n        address _beneficiary,\n        address _token,\n        uint256 _managedAmount,\n        uint256 _startTime,\n        uint256 _endTime,\n        uint256 _periods,\n        uint256 _releaseStartTime,\n        uint256 _vestingCliffTime,\n        ITokenLock.Revocability _revocable,\n        bool _canDelegate\n    ) private returns (address contractAddress) {\n\n        contractAddress = Clones.clone(masterCopy);\n\n        Address.functionCall(contractAddress, _initializer);\n\n        emit TokenLockCreated(\n            contractAddress,\n            keccak256(_initializer),\n            _beneficiary,\n            _token,\n            _managedAmount,\n            _startTime,\n            _endTime,\n            _periods,\n            _releaseStartTime,\n            _vestingCliffTime,\n            _revocable,\n            _canDelegate\n        );\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}